<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: kata | dave^2 = -1]]></title>
  <link href="http://davesquared.net/categories/kata/atom.xml" rel="self"/>
  <link href="http://davesquared.net/"/>
  <updated>2022-10-15T16:55:10+11:00</updated>
  <id>http://davesquared.net/</id>
  <author>
    <name><![CDATA[David Tchepak]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Brackets, braces, parentheses, and other such creatures]]></title>
    <link href="http://davesquared.net/2008/07/brackets-braces-parenthesis-and-other.html"/>
    <updated>2008-07-25T00:40:00+10:00</updated>
    <id>http://davesquared.net/2008/07/brackets-braces-parenthesis-and-other</id>
    <content type="html"><![CDATA[<p>I've been fairly busy the last couple of weeks finishing up my current job and preparing for my new one (a really exciting role with a team practising Scrum, TDD etc.), so I haven't been able to dedicate much time to the three potentially bloggable projects I am working on at the moment. The other day I found <a href="http://www.dev102.com/2008/07/21/a-programming-job-interview-challenge-13-brackets/">Part 13</a> of a series of coding challenges posted to <a href="http://www.dev102.com">dev102.com</a>, and thought I'd give it a go as a quick little exercise.</p>




<div class="note"><b>Note:</b> potential spoiler ahead, in the event you were intending to work through this yourself. That's not to say my solution is even vaguely correct, but if you want to do it completely off your own bat then have a go before you have all my mistakes to help you :)</div>




<h2>The problem</h2>


<p>This aim of this challenge was to determine whether any given string has a legal bracket structure. Basically, make sure all the '(', '[', '{', and '<' have matching ')', ']', '}' and '>'. We also need to take nesting into account, so that &quot;({)}&quot; is incorrect, and &quot;({}<{}>)&quot; will pass.</p>




<p>Part of the challenge is also to &quot;Provide the most efficient, elegant and simple solution&quot;. I'm not even going to attempt that, but I'll try and get something vaguely efficient and, much like this author, simple.</p>




<h2>Some quick planning</h2>


<p>Shahar Yair (who posted the challenge) notes &quot;I think that this is a well known problem&quot;. I think (although without a good googling I can't be sure due to my limited cranial capacity) one of the common implementations is to use a stack, and push brackets on as you find them, and pop them off when you close them. If you have an empty stack at the end your string is ok. If a closing bracket doesn't match the bracket on the top of the stack then you have a problem. The beautiful image below (crafted in that great image editor, MS Word) shows the basic idea: pushing on open brackets and popping them off once they get closed.</p>


<p><a href="http://davesquared.net/images/fromblogger/s1600-h-BracketStackExample.png"><img src="http://davesquared.net/images/fromblogger/s400-BracketStackExample.png" border="0" alt="Using a stack to keep track of open brackets." id="BLOGGER_PHOTO_ID_5226591626698288450" /></a></p>

<p>In terms of efficiency, the worst case for this is when you have a valid string, as you will have had to checked every character at least once (to see if it is a bracket). Using a stack will let us make a single pass through the string.</p>




<p>With this basic plan in mind, let's start writing some tests. We're not doing real TDD here I guess, as we have an end implementation in mind, but I still feel more comfortable working with the protection of some tests. It will hopefully cut down the amount of silly mistakes I normally make :).</p>




<h2>Starting small</h2>


<p>Here are a few easy tests to start off with (I'm using XUnit.NET here. I'm kind of growing attached to the simplicity of it :)):</p>




<pre>
public class When_matching_brackets {
    BracketMatcher matcher = new BracketMatcher();
    [Fact]
    public void Empty_string_should_pass() {
        should_pass(String.Empty);
    }
    [Fact]
    public void Null_string_should_pass() {
        should_pass(null);
    }    
    private void should_pass(String input) {
        Assert.True(matcher.IsValid(input));
    }
    private void should_fail(String input) {
        Assert.False(matcher.IsValid(input));
    }    
}
public class BracketMatcher {
    public bool IsValid(string input) { return true; }
}</pre>




<p>We can pass these by just returning true. Let's write a test that will make this fail:</p>




<pre>
[Fact]
public void Single_bracket() {
    should_fail("(");
}
</pre>




<p>We can cheat again to pass this:</p>




<pre>
public class BracketMatcher {
    public bool IsValid(string input) { 
        if (input == null) return true;
        return input.Length < 1;
    }
}</pre>




<p>To drive the next bit of our algorithm we can add another failing test:</p>




<pre>
[Fact]
public void Matched_brackets() {
    should_pass("()");
}
</pre>




<p>We could dodgy this up again, but let's start writing something a bit more realistic -- but only a little.</p>




<pre>
public class BracketMatcher {
    public bool IsValid(string input) {
        if (input == null) return true;
        int openBrackets = 0;

        foreach (var c in input) {
            if (c == '(') { openBrackets++; }
            else if (c == ')') { openBrackets--; }                                
        }
        return openBrackets == 0;
    }
}
</pre>




<p>This passes, but it is obviously going to incorrectly return true for an input like &quot;)(&quot;. We'll use this to write our next test. What we are doing here is slowly building up a number of cases that should have a specific result, and writing a minimal (and trivial) implementation to make the test cases pass. The actual time spent doing this is quite short. I doubt anyone would spend any more than a few minutes typing this out. What we gain is momentum, and a test suite for when the time comes to refactor. Maybe it's just me, but if I were going straight to an implementation, I'd generally make great progress for a while but stuff up a sign or an end case or similar, and then spend and inordinate amount of time manually tracing through the code to find where I had gone wrong. The slow-and-steady approach here means less initial speed, but no speed bumps later, and usually a faster* trip overall.</p>




<p style="font-size: x-small">* Caution: unsubstantiated anecdote! YMMV</p>




<h2>Skipping ahead to our first major refactoring</h2>




<p>After plugging away for a little while I've got the following test cases:</p>




<pre>
public class When_matching_brackets {
    BracketMatcher matcher = new BracketMatcher();

    [Fact]
    public void Empty_string_should_pass() {
        should_pass(String.Empty);
    }

    [Fact]
    public void Null_string_should_pass() {
        should_pass(null);
    }

    [Fact]
    public void Single_bracket_should_fail() {
        should_fail(&quot;(&quot;);
    }

    [Fact]
    public void Single_bracket_within_string_should_fail() {
        should_fail(&quot;abc(&quot;);
    }

    [Fact]
    public void Matched_brackets_should_pass() {
        should_pass(&quot;()&quot;);
    }

    [Fact]
    public void Matched_brackets_within_string_should_pass() {
        should_pass(&quot;This is (a test).&quot;);
    }

    [Fact]
    public void Matched_brackets_with_single_brace_should_fail() {
        should_fail(&quot;This {is (a test).&quot;);
    }

    [Fact]
    public void Matched_brackets_and_braces_should_pass() {
        should_pass(&quot;This {is} a (test).&quot;);
    }

    <b>[Fact]
    public void Correct_number_but_wrong_nesting_of_brackets_and_braces_should_fail() {
        should_fail(&quot;This {is a (test}).&quot;);
    }</b>

    private void should_pass(String input) {
        Assert.True(matcher.IsValid(input));
    }

    private void should_fail(String input) {
        Assert.False(matcher.IsValid(input));
    }
}
</pre>


<p></p>

<p>The last test (emphasised) is failing with the following implementation (which passes all the other tests), because it fails to take bracket nesting into account:</p>




<pre>
public class BracketMatcher {             
    public bool IsValid(string input) {
        if (input == null) return true;
        
        var bracketCount = 0;
        var braceCount = 0;
        foreach (var c in input) {                
            if (c == '(') {
                bracketCount++;
            } else if (c == ')') {
                bracketCount--;
            } else if (c == '{') {
                braceCount++;
            } else if (c == '}') {
                braceCount--;
            }
        }
        return bracketCount == 0 && braceCount == 0;
    }
}
</pre>




<p>You can also see I have duplicated the counters for braces and brackets, and we'll only be adding to this problem when it comes time to add the other bracket types. Let's refactor to remove this, and get in the stack idea we talked about earlier.</p>




<div class="note"><b>Aside:</b> Strictly speaking this isn't refactoring -- I'm changing both design and behaviour in one big step (currently there is one failing test, afterward they all pass). In this case it works out ok, but I have gotten myself into trouble many, many times by doing this kind of premature refactoring (it's a bad habit I'm trying to break). In general I'd suggest getting all your tests passing, <i>then</i> refactoring to remove duplication.</div>




<pre>
public class BracketMatcher {                  
    public bool IsValid(string input) {            
        if (input == null) return true;

        var bracketStack = new Stack&lt;char&gt;();
        foreach (var c in input) {                
            if (c == '(') {
                bracketStack.Push(c);
            } else if (c == ')') {
                if (bracketStack.Pop() != '(') return false;
            } else if (c == '{') {
                bracketStack.Push(c);
            } else if (c == '}') {
                if (bracketStack.Pop() != '{') return false;
            }
        }
        return bracketStack.Count == 0;
    }
}
</pre>


<p></p>

<p>This passes all our tests, but it's still ugly. The pushes and pops obscure the algorithm we are using. Sure, you can pick it out by tracing through a few cases, but it would be nicer to get the gist of it by inspection alone. We also have some duplicated <code>if (bracketStack.Pop() != '(') return false;</code> style code happening, but now we are at least passing all our tests, we can continue to work toward removing the ugliness without breaking what we have.</p>




<pre>
public class BracketMatcher {
    private static Dictionary&lt;char, char&gt; bracketPairs
        = new Dictionary&lt;char, char&gt; { {'(', ')'}, {'{', '}'} };

    public bool IsValid(string input) {
        if (input == null) return true;

        var bracketStack = new Stack&lt;char&gt;();
        foreach (var c in input) {
            if (bracketPairs.ContainsKey(c)) {
                bracketStack.Push(c);
            } else if (bracketPairs.ContainsValue(c)) {
                char lastBracket = bracketStack.Pop();
                if (bracketPairs[lastBracket] != c) return false;
            }
        }
        return bracketStack.Count == 0;
    }
}
</pre>




<p>This version is a bit of an improvement: we have removed the duplication by adding a dictionary of bracket pairs. It still isn't exactly intention revealing though with those key/value checks and pushing and popping. I'll go out on a limb here though, and suggest that it's much better than the implementation we opened this section with.</p>


<p></p>

<h2>Finishing up</h2>


<p>A few more tests, and a refactoring later, and here's what I ended up with:</p>




<pre>
public class BracketMatcher {
    private static readonly Dictionary&lt;char, char&gt; bracketPairs
        = new Dictionary&lt;char, char&gt; { {'(', ')'}, {'{', '}'}, {'[', ']'}, {'&lt;', '&gt;'} };

    private Stack&lt;char&gt; bracketStack;

    <b>public bool IsValid(string input) {        
        if (input == null) return true;
        clearOpenedBrackets();
        foreach (var c in input) {
            if (isOpenBracket(c)) {
                recordBracketOpening(c);
            } else if (isCloseBracket(c)) {
                if (!canCloseLastOpenBracket(c)) return false;
                closeLastOpenedBracket();                    
            }
        }
        return areAllBracketsClosed();
    }</b>

    private void clearOpenedBrackets() {
      bracketStack = new Stack&lt;char&gt;();
    }

    private bool areAllBracketsClosed() {
      return bracketStack.Count == 0;
    }

    private void closeLastOpenedBracket() {
        bracketStack.Pop();
    }

    private bool canCloseLastOpenBracket(char bracket) {
        if (areAllBracketsClosed()) return false;
        char lastOpenBracket = bracketStack.Peek();
        char closingBracket = bracketPairs[lastOpenBracket];
        return bracket == closingBracket;
    }

    private void recordBracketOpening(char bracket) {
        bracketStack.Push(bracket);
    }

    private bool isOpenBracket(char c) {
        return bracketPairs.ContainsKey(c);
    }

    private bool isCloseBracket(char c) {
        return bracketPairs.ContainsValue(c);
    }
}
</pre>




<p>I think <code>IsValid(...)</code> is actually reading pretty well here. The intent of the operation is fairly clear from a quick read through, with no implementation details like pops and pushes scattered around the code. The implementation itself is pushed to fairly simple helper methods.</p>




<p>The <code>canCloseLastOpenBracket(...)</code> method is a bit ugly, but it is only four lines, has descriptive variable names, and is tucked away in a private method. It's also a bit inefficient, as we are doing an unecessary <code>Peek()</code> before <code>Pop()</code>ing the value off the stack. I rewrote the code several ways, but any approach that combined the <code>Pop()</code> with matching the brackets tended to obscure what the code was doing. I've had a minor method-count explosion, but they are all small and self-explanatory (less lines that commenting the previous version in any event ;)).</p>




<p>We might be able to simplify this in a number of ways, like putting the required closing brackets on the stack to make the matching more straightforward, but the other approaches I tried all seemed to compromise readability to some extent, so I ended up sticking with the verbosity of this version. I'm sure you can do better (leave a comment!), but for now it's passing the tests thrown at it and I can live with how it reads. Which means we're as good as done. :)</p>




<p>Speaking of done, here's the test suite it passes:</p>




<pre>
public class When_matching_brackets {
    BracketMatcher matcher = new BracketMatcher();

    [Fact]
    public void Empty_string() {
        should_pass(String.Empty);
    }

    [Fact]
    public void Null_string() {
        should_pass(null);
    }

    [Fact]
    public void Single_bracket() {
        should_fail(&quot;(&quot;);
    }

    [Fact]
    public void Single_closing_bracket() {
        should_fail(&quot;)&quot;);
    }

    [Fact]
    public void Single_bracket_within_string() {
        should_fail(&quot;abc(&quot;);
    }

    [Fact]
    public void Matched_brackets() {
        should_pass(&quot;()&quot;);
    }

    [Fact]
    public void Matched_brackets_within_string() {
        should_pass(&quot;This is (a test).&quot;);
    }

    [Fact]
    public void Missing_a_brace() {
        should_fail(&quot;This {is (a test).&quot;);
    }

    [Fact]
    public void Pairs_of_matched_brackets_and_braces() {
        should_pass(&quot;This {is} a (test).&quot;);
    }

    [Fact]
    public void Incorrect_nesting_of_brackets_and_braces() {
        should_fail(&quot;This {is a (test}).&quot;);
    }

    [Fact]
    public void Valid_nesting_with_multiple_types() {
        should_pass(&quot;&lt;Hello (World), ({how} are) you today&gt;?&quot;);
    }

    [Fact]
    public void Multiple_pairs() {
        should_pass(&quot;(Hello) {World}, &lt;how&gt; are (you) today?&quot;);
    }

    [Fact]
    public void Multiple_lines_with_valid_brackets() {
        should_pass(@&quot;(Hello {World,
                        How are you}
                        ?)&quot;);
    }

    [Fact]
    public void Multiple_lines_with_invalid_brackets() {
        should_fail(@&quot;(Hello {World,
                        How are you)
                        ?)&quot;);
    }

    [Fact]
    public void Valid_example_from_problem_statement() {
        should_pass(&quot;([](&lt;{}&gt;))&quot;);
    }

    [Fact]
    public void Invalid_example_from_problem_statement() {
        should_fail(&quot;({&lt;)&gt;}&quot;);
    }

    [Fact]
    public void Matching_square_brackets() {
        should_pass(&quot;[asdf]&quot;);
    }

    [Fact]
    public void Single_square_bracket() {
        should_fail(&quot;[&quot;);
    }

    [Fact]
    public void Single_angle_bracket() {
        should_fail(&quot;&lt;&quot;);
    }
    [Fact]
    public void Matching_angle_brackets() {
        should_pass(&quot;&lt;&gt;&quot;);  
    }

    private void should_pass(String input) {
        Assert.True(matcher.IsValid(input));
    }

    private void should_fail(String input) {
        Assert.False(matcher.IsValid(input));
    }
}
</pre>




<p>Was a bit of fun for a half hour or so :) Please feel free to leave a comment if you have any suggested improvements (or better yet, some failing tests!).</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[99 problems with Python (1-10)]]></title>
    <link href="http://davesquared.net/2008/03/99-problems-with-python-1-10.html"/>
    <updated>2008-03-29T22:16:00+11:00</updated>
    <id>http://davesquared.net/2008/03/99-problems-with-python-1-10</id>
    <content type="html"><![CDATA[<p>No, this is not a rant about problems I have with Python. I actually quite like it. Rather, it's my attempt to complete some of the <a href="https://prof.ti.bfh.ch/hew1/informatik3/prolog/p-99/">Dr Werner Hett's 99 Prolog logic problems</a> using Python, as a way of getting to learn a bit about the language. I first heard about the 99 Problems from <a href="http://www.frickinsweet.com/99problems/post/Starting-things-off.aspx">Joel and Ryan Lanciaux's efforts to solve the problems using F#</a>, who were in turn inspired by the <a href="http://curiouscoding.wordpress.com/2008/02/11/learning-ruby-with-ninety-nine-problems-1-10/">Ruby implementations on the Curious Coding blog</a>.</p>




<p>Keep in mind that I'm new to Python (have jumped into this exercise straight after reading the excellent <a href="https://en.wikipedia.org/wiki/Mark_Pilgrim#Dive_Into_Python">Dive into Python</a>), so much of this might be pretty clumsy. I'd love to hear any suggestions for improvements. I am also not entirely keeping with the original spirit of the Prolog exercise in terms of <a href="http://en.wikipedia.org/wiki/Logic_programming">logic programming</a>, as my main purpose is familiarising myself with Python. I have, however, tried to do things in a fairly Pythonic, <a href="http://en.wikipedia.org/wiki/Functional_programming">functional-style</a> rather than C/C++/Java/C#, <a href="http://en.wikipedia.org/wiki/Imperative_programming">imperative</a>-style. I'm also not concerned with error handling or edge cases, just in getting the basic syntax and approach right. I'm not sure I'll get through all 99 problems, but at the very least here's the first 10.</p>




<ul id="postAnchor_99ProbsPython_1to10_ToC">
<li><a href="#postAnchor_99ProbsPython_1to10_Intro">Implementation overview</a></li>
<li><a href="#postAnchor_99ProbsPython_1to10_P01">Problem 1: Find the last element of a list</a></li>
<li><a href="#postAnchor_99ProbsPython_1to10_P02">Problem 2: Find the last but one element of a list</a></li>
<li><a href="#postAnchor_99ProbsPython_1to10_P03">Problem 3: Find the K'th element of a list</a></li>
<li><a href="#postAnchor_99ProbsPython_1to10_P04">Problem 4: Find the number of elements of a list</a></li>
<li><a href="#postAnchor_99ProbsPython_1to10_P05">Problem 5: Reverse a list</a></li>
<li><a href="#postAnchor_99ProbsPython_1to10_P06">Problem 6: Find out whether a list is a palindrome</a></li>
<li><a href="#postAnchor_99ProbsPython_1to10_P07">Problem 7: Flatten a nested list structure</a></li>
<li><a href="#postAnchor_99ProbsPython_1to10_P08">Problem 8: Eliminate consecutive duplicates of list elements</a></li>
<li><a href="#postAnchor_99ProbsPython_1to10_P09">Problem 9: Pack consecutive duplicates of list elements into sublists</a></li>
<li><a href="#postAnchor_99ProbsPython_1to10_P10">Problem 10: Run-length encoding of a list</a></li>
<li><a href="#postAnchor_99ProbsPython_1to10_Conclusion">Conclusion</a></li>
</ul>




<h2 id="postAnchor_99ProbsPython_1to10_Intro">Implementation overview</h2>


<p>I did the exercise in <a href="http://www.eclipse.org/">Eclipse</a> with <a href="http://pydev.sourceforge.net/">PyDev plugin</a>, and used the Python <a href="http://docs.python.org/lib/module-unittest.html">unittest</a> module to implement each solution as a test to make it easy to run and verify each solution. You can obviously run all this using IDLE or whatever Python runner you like. Here's the basic file structure I started off with:</p>




<pre>
import unittest

class NinetyNineProblemsFixture(unittest.TestCase):
    
  def testXX_Description(self):
    def solutionToProblem(input): pass          
    input = "some input"
    expected = "expected output for successful implementation"    
    self.assertEqual(expected, solutionToProblem(input))  
  
if __name__ == '__main__':
  unittest.main()
</pre>




<p>I wrote a test for each problem, then implemented the solution as an inner function within the test. The <code>if __name__ == '__main__'</code> line lets you run the tests by simply running your *.py file through Python. I tended to run using PyTest.py from within Eclipse/PyDev.</p>




<p style="font-size: x-small"><a href="#postAnchor_99ProbsPython_1to10_ToC">Back to table of contents...</a></p>




<h2 id="postAnchor_99ProbsPython_1to10_P01">P01 Find the last element of a list</h2>


<pre>
  def test01_FindLastElementOfList(self):
    <b>def getLast(list):
      return list[-1]</b>
    list = [1, 3, 7, 14]
    self.assertEqual(14, getLast(list))
</pre>


<p>Lists are great in Python. They have lots of nice features that make them very pleasant to work with. This example shows one of these features, you can use a negative index to get list items from the end of the list. For example, <code>list[-3]</code> will get the third last item in the list. In this case, we want the last element, so we use <code>list[-1]</code>.</p>




<p style="font-size: x-small"><a href="#postAnchor_99ProbsPython_1to10_ToC">Back to table of contents...</a></p>




<h2 id="postAnchor_99ProbsPython_1to10_P02">P02 Find the last but one element of a list</h2>


<p>Same as P01, but we want the second last item:</p>


<pre>
  def test02_FindLastButOne(self):
    <b>def getLastButOne(list):
      return list[-2]</b>
    list = [1, 3, 7, 14]
    self.assertEqual(7, getLastButOne(list))
</pre>




<p style="font-size: x-small"><a href="#postAnchor_99ProbsPython_1to10_ToC">Back to table of contents...</a></p>




<h2 id="postAnchor_99ProbsPython_1to10_P03">P03 Find the K'th element of a list</h2>


<p>Basic array index for this. Lists indicies are zero-based in Python (as they should be :)), but the problem definition wants to translate the reference to 1-based.</p>


<pre>
  def test03_FindKthElement(self):
    def getKth(list, k):
      return list[k-1]
    list = [1, 3, 7, 14]
    self.assertEqual(3, getKth(list, 2))
</pre>




<p style="font-size: x-small"><a href="#postAnchor_99ProbsPython_1to10_ToC">Back to table of contents...</a></p>




<h2 id="postAnchor_99ProbsPython_1to10_P04">P04 Find the number of elements of a list</h2>


<p>Cheating for this one and just use the built in <code>len</code> function:</p>


<pre>
  def test04_NumberOfElementsInList(self):
    <b>def getCount(list):
      return len(list)</b>
    list = [1, 3, 7, 14]    
    self.assertEqual(4, getCount(list))   
</pre>




<p style="font-size: x-small"><a href="#postAnchor_99ProbsPython_1to10_ToC">Back to table of contents...</a></p>




<h2 id="postAnchor_99ProbsPython_1to10_P05">P05 Reverse a list</h2>


<p>Here I played around with two different approaches so as to learn a bit about Python list slicing.</p>




<div class="note">
<p><b>Update (2 April 2008):</b> Initially I did not realise that there was a built-in <code>reversed()</code> function. I originally had something silly like this:</p>
<pre>
    def reverse(l):
      newList = list(l)      
      return newList.reverse() or newList
</pre>

<p>The <code>list.reverse</code> function does an in-place reversal of the list elements and returns <code>None</code> (the Python null value), so I had to clone the list first so as not to affect the original, then OR it to return the list reference itself. Thanks to <a href="http://reddit.com/r/Python/info/6e168/comments/c03l8i6">Mark</a> et al. on <a href="http://reddit.com/r/Python/info/6e168/comments">Reddit</a> for showing me the light! :)</p>
</div>




<pre>
  def test05_ReverseAList(self):
    <b>def reverse(l):
      return list(reversed(aList))</b>
    <b>def manualReverse(list):          
      return list[::-1]</b>
    sampleList = [1, 3, 7, 14]
    self.assertEqual([14, 7, 3, 1], reverse(sampleList))
    self.assertEqual([14, 7, 3, 1], manualReverse(sampleList))
</pre>




<p>The <code>reversed()</code> function returns an iterator, so it is wrapped in a <code>list()</code> constructor to convert it to a new list. I used <code>l</code> for the method parameter, as I couldn't figure out how to appropriately qualify references to the <code>list</code> class when it was hidden by a parameter called <code>list</code> (cue embarrassed smiley).</p>




<h3>List slicing</h3>


<p>The second approach was to use Python's list <em>slicing</em>. A <em>slice</em> is a range of values copied from an original list. This means we have no side effects like we do using the in place <code>reverse()</code>. The basic syntax for a slice is:</p>




<pre>list[indexOfFirstElementInSlice : indexOfFirstElement_Not_InSlice : optionalStep]</pre>




<p>Omitting the first argument starts the slice from the first list element. Omitting the second argument takes the remainder of elements in the list. The step can be set to, say, 2 to take every second list element. It's worth noticing that the second argument is exclusive, so that we can the following from the Python interpreter:</p>




<pre>
&gt;&gt;&gt; aList = range(0, 6)
&gt;&gt;&gt; aList
[0, 1, 2, 3, 4, 5]
&gt;&gt;&gt; #From index 1 up to, but excluding, index 5:
&gt;&gt;&gt; aList[1:5]
[1, 2, 3, 4]
&gt;&gt;&gt; aList[1::2]
[1, 3, 5]
</pre>




<p>In our case we want the slice to include all the elements, but we want to take them in reverse order, which is how we end up with <code>list[::-1]</code>. Right, that was all a lot of explanation for not-much-code, but I thought I'd point out some Python basics along the way.</p>




<p style="font-size: x-small"><a href="#postAnchor_99ProbsPython_1to10_ToC">Back to table of contents...</a></p>




<h2 id="postAnchor_99ProbsPython_1to10_P06">P06 Find out whether a list is a palindrome</h2>


<p>A palindrome is something that reads the same forward as it does backwards, like &quot;Go hang a salami, I'm a lasagna hog&quot;* (well, ignoring punctuation and spaces). I tried two different approaches for this one too.</p>




<pre>
  def test06_IsListAPalindrome(self):
    <b>def isPalindrome(aList):
      return aList == aList[::-1]</b>
    <b>def isPalindromeRecursive(aList):
      if (len(aList)&lt;=1): return True
      top, tail = aList[0], aList[-1]          
      if (top != tail): return False
      return isPalindromeRecursive(aList[1:-1])</b>
    palindromes = [
                   ['a', 'b', 'c', 'b', 'a'],
                   [1, 10, 20, 30, 30, 20, 10, 1],
                   ['a', 'a']                    
                   ]
    nonPalindromes = [
                      ['a', 'b', 'c', 'd'],
                      [1, 10, 20, 20, 10, 2],
                      ['a', 'v']
                      ]    
    self.assertTrue(all([isPalindrome(x) for x in palindromes]))
    self.assertTrue(all([not isPalindrome(x) for x in nonPalindromes]))
    
    self.assertTrue(all([isPalindromeRecursive(x) for x in palindromes]))
    self.assertTrue(all([not isPalindromeRecursive(x) for x in nonPalindromes]))
</pre>




<p>The first way is cheating, but effective. Simply use <code>return aList == aList[::-1]</code> to compare the list with a reverse slice, using the same slicing syntax used for P05. This will obviously ensure the list reads the same forwards as backwards.</p>




<p>The second way uses recursion, as well as logical list operations to get the same effect. Let's break it down:</p>




<pre>if (len(aList)&lt;=1): return True</pre>




<p>A list of 0 or 1 elements will read the same forwards as backwards, right? So yes, we have a palindrome.</p>




<pre>top, tail = aList[0], aList[-1]          
if (top != tail): return False</pre>




<p>Ok, now we look at first and last elements of the list (the latter of which I inconveniently named <code>tail</code>, which is normally used to refer to the remainder of the list besides the first element, head/tail semantics). This line also shows how you can do multiple assignments over one line in Python. You can also use a similar syntax return multiple values from one function, which we'll see later if you make it that far without getting bored :). The second line of the fragment then compares these elements -- if they are not equal then the list can't be a palindrome (e.g. <b>1</b> 2 3 2 <b>7</b>, the 1 and 7 don't match so the list isn't a palindrome).</p>




<p>If the first and last elements <b>are</b> equal, then we have a potential palindrome, and use <a href="http://en.wikipedia.org/wiki/Tail_recursion">tail recursion</a> to check whether a slice of the list, excluding the first and last elements, is a palindrome. Which seems to work nicely.</p>




<p style="font-size: x-small">* A fine <a href="http://en.wikipedia.org/wiki/Bob_(song)">lesson in palindromes</a> is available from Mr Yankovic album. You might be able to find a version <a href="http://www.youtube.com/watch?v=Nej4xJe4Tdg">somewhere</a> without too much trouble, strictly for educational purposes.</p>




<p style="font-size: x-small"><a href="#postAnchor_99ProbsPython_1to10_ToC">Back to table of contents...</a></p>




<h2 id="postAnchor_99ProbsPython_1to10_P07">P07 Flatten a nested list structure</h2>


<p>This problem just wants us to take a nested list, like <code>[1, [2, 3], [4, 5, [6, 7]]]</code>, and flatten it out to a 1-dimensional list, like <code>[1, 2, 3, 4, 5, 6, 7]</code>. After coming up with a fairly ugly solution I ended up peeking at the <a href="http://curiouscoding.wordpress.com/2008/02/20/p07-flatten-a-nested-array-structure/">Curious Coding solution</a>, and adapted it to Python. This is also the first problem in the set marked as a 2-star problem, or &quot;intermediate difficulty&quot; (the others have all been marked as 1-star, or &quot;easy&quot;).</p>


<pre>
  def test07_FlattenAList(self):
    <b>def flatten(aList):
      flatList = []      
      for item in aList:
        if (type(item)==list):
          flatList.extend(flatten(item))
        else:
          flatList.append(item)          
      return flatList</b>
    self.assertEqual(
                     [1, 2, 3, 4, 5, 6, 7], 
                     flatten([1, [2, 3], [4, 5, [6, 7]]])
                     )
</pre>


<p>Points of note from this problem is the use of the <code>type()</code> method (well, <code>type</code> is actually a &quot;type&quot;, which, like everything in Python, is an object). This is used to check if the current element is a list. If so, the flattened list is extended by the flattened version of that sub-list (via a recursive call to <code>flatten()</code>). If not, the element is appended to the flatList.</p>




<p>The <code>extend()</code> method adds the items from a list to another list, whereas <code>append()</code> adds the item from as a single element to the list. This is probably best shown with an example:</p>




<pre>
&gt;&gt;&gt; aList = range(0,6)
&gt;&gt;&gt; aList
[0, 1, 2, 3, 4, 5]
&gt;&gt;&gt; bList = list(aList)
&gt;&gt;&gt; bList
[0, 1, 2, 3, 4, 5]
&gt;&gt;&gt; anotherList
[6, 7]
&gt;&gt;&gt; <b>aList.append(anotherList)</b>
&gt;&gt;&gt; <b>bList.extend(anotherList)</b>
&gt;&gt;&gt; aList
[0, 1, 2, 3, 4, 5, <b>[6, 7]</b>]
&gt;&gt;&gt; bList
[0, 1, 2, 3, 4, 5, <b>6, 7</b>]
</pre>




<p style="font-size: x-small"><a href="#postAnchor_99ProbsPython_1to10_ToC">Back to table of contents...</a></p>




<h2 id="postAnchor_99ProbsPython_1to10_P08">P08 Eliminate consecutive duplicates of list elements</h2>


<p>This is another 2-star, intermediate problem, but it was pretty easy to whip through using Python's <a href="http://en.wikipedia.org/wiki/List_comprehensions">list comprehensions</a>. Let's have a quick look at the list comprehension syntax first:</p>




<pre><b>[</b>itemInNewList <b>for</b> itemInNewList <b>in</b> someList <b>if</b> someConditionIsMet<b>]</b></pre>




<p>The square braces (<code>[, ]</code>) indicate we are creating a new list. In the new list we will include <code>itemInNewList</code> as an element, for the <code>itemInNewList</code> values in <code>someList</code> (or other iterable), that meet <code>someConditionIsMet</code> (the <code>if someConditionIsMet</code> is optional). Quick example:</p>




<pre>&gt;&gt;&gt; aList = range(0,6)
&gt;&gt;&gt; aList
[0, 1, 2, 3, 4, 5]
&gt;&gt;&gt; [item for item in aList if item &lt; 3]
[0, 1, 2]
</pre>




<p>All a bit LINQ-like to me (well, more correctly <a href="http://research.microsoft.com/~emeijer/Papers/LINQ20.pdf">LINQ is inspired by features in functional programming, such as monads [PDF]</a>).</p>




<p>Back to problem 8, the aim is to eliminate consecutive duplicates from a list. So we would like to create a new list by iterating over a source list, and only including elements that are not the same as the previous element.</p>


<pre>
  def test08_EliminateConsecutiveDuplicates(self):
    <b>def compress(aList):
      return [item for index, item in enumerate(aList) if index==0 or item != aList[index-1]]</b>
    sampleList = ['a','a','a','a','b','c','c','a','a','d','e','e','e','e']
    self.assertEqual(
                     ['a','b','c','a','d','e'],
                     compress(sampleList)                     
                     )
</pre>




<p>The only tricky bit with this list comprehension compared with the trivial example given above is the use of the <code>enumerate(aList)</code> function which returns two values per iteration, the <code>item</code> and the <code>index</code> of that item. We use these variables in the list comprehension condition to check whether this is the first list item (which we want to include), or if the list item duplicates the previous one (which we want to exclude).</p>




<p>I think that's awesome :)</p>




<p style="font-size: x-small"><a href="#postAnchor_99ProbsPython_1to10_ToC">Back to table of contents...</a></p>




<h3>From comments: avoiding <code>enumerate()</code></h3>


<p>Arnar <a href="http://www.blogger.com/profile/12073820949049315334">(Blogger profile link)</a> left a nice solution for this problem in the <a href="http://davesquared.net/2008/03/99-problems-with-python-1-10.html?showComment=1206981120000#c3437122901944431864">comments</a> that doesn't require the use of <code>enumerate()</code>. I've reproduced it here (updating the naming convention to match the example above):</p>




<pre>
    def compress(aList):
        return aList[:1] + [aList[i] for i in range(1, len(aList)) if aList[i-1] != aList[i]]
</pre>




<p>This first creates a list containing only the head element (<code>aList[:1]</code>), and concatenates it with a list comprehension that eliminates duplicates. Rather than using <code>enumerate()</code> to get the index and item, Arnar used <code>range(1, len(aList))</code> (which I have <a href="http://davesquared.net/2008/01/python-like-range-implementation-in-c.html">blogged about before</a>) to generate the relevant indexes and then accesses the items direct from the list.</p>




<p>The nice thing about this approach is that by starting with <code>aList[:1]</code>, we simplify the list comprehension condition I originally had (<code>if <b>index==0</b> or item != aList[index-1]</code>). I'm not sure if there is a clear advantage of using <code>enumerate()</code> or <code>range()</code> to iterate over, but it definitely gave me another way of thinking about the problem. Thanks Arnar! :)</p>




<h3>From comments: using itertools.groupby</h3>


<div class="note">This example added 3 April 2008</div>


<p>I had a number of helpful comments suggesting I use the <a href="http://docs.python.org/lib/itertools-functions.html"><code>itertools</code></a> standard Python library for a number of these examples. Thanks to <a href="http://www.blogger.com/profile/12073820949049315334">Arnar</a>, <a href="http://davesquared.net/2008/03/99-problems-with-python-1-10.html?showComment=1207152840000#c1065796923200770025">Niall</a>, <a href="http://davesquared.net/2008/03/99-problems-with-python-1-10.html?showComment=1207153740000#c8507599583786575534">Mohammad</a> and everyone else that suggested this and wrote in with examples. I originally intended to do this exercise without using any imports (well, except for <code>unittest</code>), but <a href="http://davesquared.net/2008/03/99-problems-with-python-1-10.html?showComment=1207044600000#c3670614047789933344">Arnar</a> managed to <a href="http://davesquared.net/2008/03/99-problems-with-python-1-10.html?showComment=1207078140000#c1479086697219868845">convince me</a> to stop being so silly. :)</p>


<p>The particular <code>itertools</code> function we are looking at is <code>groupby(iterable[, key])</code>. This function returns a list of tuples. The first item in the tuple is the key for a particular group, and the second is an iterator over the group itself (i.e. <code>(key, group)</code>). So how are keys specified? By default, it is the item's identity or value (so if you group [1, 1, 1, 2, 3], you will get a group of 1s, like this:</p>


<pre>
&gt;&gt;&gt; from itertools import groupby
&gt;&gt;&gt; aList = [<b>1,1,1</b>,2,3]
&gt;&gt;&gt; [<b>list(group)</b> for key, group in groupby(aList)]
[<b>[1, 1, 1]</b>, [2], [3]]
&gt;&gt;&gt; [key for key, group in groupby(aList)]
[1, 2, 3]
</pre>




<p>Note we have to import the function from the <code>itertools</code> library first using <code>from itertools import groupby</code> (<a href="http://diveintopython.org">Dive Into Python</a> has a <a href="http://diveintopython.org/object_oriented_framework/importing_modules.html">great explanation about how to import stuff</a>). As the <code>group</code> returned is an iterator over a group, we can turn it into a list using the constructor <code>list(group)</code>. The last command issue also shows what keys <code>groupby()</code> finds when no <code>key</code> argument is supplied. We can also provide <code>groupby()</code> with a function used to calculate keys:</p>




<pre>
&gt;&gt;&gt; aList
[1, 1, 1, 2, 3]
&gt;&gt;&gt; [list(group) for key, group in groupby(aList, <b>lambda x: x&lt;3</b>)]
[[1, 1, 1, 2], [3]]
</pre>




<p>Here we use a simple lambda function to sort the list into groups: those less than 3, and not. :) Armed with just enough knowledge to be dangerous, let's try and solve problem 8 again. To eliminate consecutive duplicates, all we really want to do is get the keys from the list:</p>




<pre>
  def test08_EliminateConsecutiveDuplicates(self):
    <b>def compress(aList):        
        return [key for key, group in groupby(aList)]</b>
    sampleList = ['a','a','a','a','b','c','c','a','a','d','e','e','e','e']
    self.assertEqual([<b>'a'</b>,'b','c',<b>'a'</b>,'d','e'], compress(sampleList))
</pre>




<p>And this passes nicely. But hold on a minute! How come we have duplicated keys in there? There are to <b>'a'</b> elements! I said the default keys were each item's identity, and they are both <b>'a'</b>! Why are you lying Dave? WHY?!?!</p>




<p>Ok, I'm better now. The reason is that <code>groupby()</code> is implemented using an iterator. It goes through the list picking out items in the <b>'a'</b> group, then hits <b>'b'</b>. This has a different identity, and so starts a new group. The function's iterator has now moved past the initial group of 4 <b>'a'</b> elements, and has basically completely forgotten about them, so the next time it hits an <b>'a'</b> it creates a new group. Clear as mud? Check out the <a href="http://docs.python.org/lib/itertools-functions.html#l2h-1064">documentation</a> and it should clear things up ( worked for me :) )</p>




<p style="font-size: x-small"><a href="#postAnchor_99ProbsPython_1to10_ToC">Back to table of contents...</a></p>




<h2 id="postAnchor_99ProbsPython_1to10_P09">P09 Pack consecutive duplicates of list elements into sublists</h2>


<p>Another 2 star problem, this one wants us to convert consecutive duplicates in a list into a sub-lists. The <a href="https://prof.ti.bfh.ch/hew1/informatik3/prolog/p-99/">original problem</a> says something about only packing duplicates if list contains duplicates, but the example and implementations I have seen do not seem to do this, so I'll follow convention of blindly packing each element into a sub-list.</p>




<pre>
  def test09_PackDuplicatesIntoSubLists(self):
    <b>def pack(aList):
      packedList = []
      for index, item in enumerate(aList):
        if index==0 or item != aList[index-1]:
          packedList.append([item])
        else:  
          packedList[-1].append(item)
      return packedList</b>
    
    sampleList = ['a','a','a','a','b','c','c','a','a','d','e','e','e','e']
    self.assertEqual(
                     [['a','a','a','a'],['b'],['c','c'],['a','a'],['d'],['e','e','e','e']],
                     pack(sampleList)                     
                     )
</pre>




<p>I couldn't find a nice way of doing this list comprehension style, so I resorted to a simple imperative operation. We start with an empty <code>packedList</code>, and use the nice <code>enumerate()</code> that was so useful in problem 8 to iterate over the source list. If this is the first element, or if this element is not duplicating the previous item, we will append a one element, sub-list to <code>packedList</code> (<code>packedList.append(<b>[</b>item<b>]</b>)</code>). This means that every element of <code>packedList</code> will be a list itself. This is important, because the <code>else</code> branch of this condition relies on this fact to simply add duplicate elements to the previous sub-list (<code>packedList[-1].append(item)</code>).</p>




<p>At this point I'm seriously loving how easy it is to use Python lists: slicing, list comprehensions, negative indexing etc. Test passes, so it's off to our final question for this set.</p>




<h3>From comments: another itertools.groupby alternative</h3>


<div class="note">This example added 3 April 2008.</div>


<p>As noted in the follow ups to <a href="#postAnchor_99ProbsPython_1to10_P08">problem 8</a>, a number of commenters pointed me to the <code>groupby()</code> function (see <a href="#postAnchor_99ProbsPython_1to10_P08">problem 8</a> for an explanation). We can use it here too, but this time we want the groups rather than the keys:</p>




<pre>
  def test09_PackDuplicatesIntoSubLists(self):
    <b>def pack(aList):
        return [list(group) for key, group in groupby(aList)]</b>
    sampleList = ['a', 'a', 'a', 'a', 'b', 'c', 'c', 'a', 'a', 'd', 'e', 'e', 'e', 'e']
    self.assertEqual(
                     [['a','a','a','a'], ['b'], ['c','c'], ['a','a'], ['d'], ['e','e','e','e']],
                     pack(sampleList)                     
                    )
</pre>




<p style="font-size: x-small"><a href="#postAnchor_99ProbsPython_1to10_ToC">Back to table of contents...</a></p>




<h2 id="postAnchor_99ProbsPython_1to10_P10">P10 Run-length encoding of a list</h2>


<p>This problem relates to problem 9, but instead of showing multiple elements in each sub-list, we just want a count of how many duplicates there are. Let's have a look at the test assertion to make this clearer:</p>




<pre>
    ...
    sampleList = ['a','a','a','a','b','c','c','a','a','d','e','e','e','e']
    self.assertEqual(
                     [[4,'a'],[1,'b'],[2,'c'],[2,'a'],[1,'d'],[4,'e']],
                     encode(sampleList)
                     )
</pre>




<p>First I tackled this the easy way, using copy-and-paste reuse from problem 9 and changing the action on each branch. The implementation is show below, with differences from problem 9 emphasised:</p>




<pre>
    def encode(aList):
      encodedList = []
      for index, item in enumerate(aList):
        if index==0 or item != aList[index-1]:
          <b>encodedList.append([1, item])</b>
        else:  
          <b>encodedList[-1][0] += 1</b>
      return encodedList
</pre>




<p>Here, rather than appending to sub-lists all the time, we are keeping a structure that contains the number of duplicates and the item being duplicated in each list. That worked, passing the test show above, but I also tried a less-objectional form of reuse of the <code>pack()</code> function from P09 by calling it from a list comprehension:</p>




<pre>
    def encode2(aList):
      return [<b>[len(packed), packed[0]]</b> for packed in <b>pack(aList)</b>]    
</pre>




<p>This list comprehension is making a new list from every sub-list returned by the <code>pack()</code> function. Each item is a two item list (<code>[len(packed), packed[0]]</code>). The first item is the length of the sub-list (i.e. how many duplicates we have), and the second is the first item of the sub-list (i.e. the item being duplicated). Here is the complete test:</p>




<pre>
  def test10_RunLengthEncodeList(self):    
    <b>def encode(aList):
      encodedList = []
      for index, item in enumerate(aList):
        if index==0 or item != aList[index-1]:
          encodedList.append([1, item])
        else:  
          encodedList[-1][0] += 1
      return encodedList</b>
    def pack(aList):
      packedList = []
      for index, item in enumerate(aList):
        if index==0 or item != aList[index-1]:
          packedList.append([item])
        else:  
          packedList[-1].append(item)
      return packedList
    <b>def encode2(aList):
      return [[len(packed), packed[0]] for packed in pack(aList)]</b>
      
    sampleList = ['a','a','a','a','b','c','c','a','a','d','e','e','e','e']
    self.assertEqual(
                     [[4,'a'],[1,'b'],[2,'c'],[2,'a'],[1,'d'],[4,'e']],
                     encode(sampleList)
                     )
    self.assertEqual(
                     [[4,'a'],[1,'b'],[2,'c'],[2,'a'],[1,'d'],[4,'e']],
                     encode2(sampleList)
                     )   
</pre>




<h3>From comments: yet another itertools.groupby alternative</h3>


<div class="note">This example added 3 April 2008.</div>


<p>As noted in the follow ups to <a href="#postAnchor_99ProbsPython_1to10_P08">problem 8</a> and <a href="#postAnchor_99ProbsPython_1to10_P09">problem 9</a>, I really should have been using the <code>groupby()</code> function for some of these problems (see <a href="#postAnchor_99ProbsPython_1to10_P08">here</a> for an explanation).</p>




<pre>
  def test10_RunLengthEncodeList(self):    
    <b>def encode3(aList):
      return [[len(list(group)), key] for key, group in groupby(aList)]</b>
    sampleList = ['a','a','a','a','b','c','c','a','a','d','e','e','e','e']
    self.assertEqual(
                     [[4,'a'], [1,'b'], [2,'c'], [2,'a'], [1,'d'], [4,'e']],
                     encode3(sampleList)
                    )
</pre>




<p>This is pretty similar in form to the second approach used (<code>encode2()</code>), but without having to call <code>pack</code> first.</p>




<p style="font-size: x-small"><a href="#postAnchor_99ProbsPython_1to10_ToC">Back to table of contents...</a></p>




<h2 id="postAnchor_99ProbsPython_1to10_Conclusion">Conclusion</h2>


<p>Because all the problems so far revolved around lists, an area in which Python excels, I think all of these implementations came out quite well, especially considering I have no idea what I am doing when it comes to Python (or at all, some might argue!).</p>




<p>Looking at the <a href="http://curiouscoding.wordpress.com/2008/02/11/learning-ruby-with-ninety-nine-problems-1-10/">Ruby implementations</a>, there are a number of similarities between the Python versions I came up with. To be fair, I did peek at some of the Ruby solutions for hints in keeping to a functional programming style, but my main point here is that the language differences for basic stuff <a href="http://groups.google.com/group/comp.lang.python/msg/28422d707512283">seem fairly superficial</a>. I found both the Ruby versions and the Python versions very easy to understand.</p>




<p>Perhaps because it has been many, many years since I worked with Haskell, I found the <a href="http://www.frickinsweet.com/99problems/post/Starting-things-off.aspx">F# samples from the Lanciaux brothers</a> much more difficult to understand. The language semantics are just so different. Although all of them seem more natural to me than the <a href="https://prof.ti.bfh.ch/hew1/informatik3/prolog/p-99/">original Prolog solutions</a> :-) Take a look at the solutions to problem 8 and see if you agree:</p>




<ul>
  <li><a href="https://prof.ti.bfh.ch/hew1/informatik3/prolog/p-99/p08.pl">Problem 8 in Prolog</a></li>
  <li><a href="http://curiouscoding.wordpress.com/2008/02/21/p08-eliminate-consecutive-duplicates-of-array-elements/">Problem 8 in Ruby</a></li>
  <li><a href="http://www.frickinsweet.com/99problems/post/Problem-8.aspx">Problem 8 in F#</a></li>
  <li><a href="#postAnchor_99ProbsPython_1to10_P08">Problem 8 in Python</a></li>
</ul>




<p>All in all I had a thoroughly good time using Python for this exercise, and will definitely be looking for any excuse to use it again in future. At least for this basic stuff, the language just seems so concise and easy express your intention through the syntax. If you have suggestions for improvements or find any bugs with this please leave a comment or send me an email (tchepak at gmail). [UPDATE: Thanks to all those who have helped out with comments so far!]</p>




<p style="font-size: x-small"><a href="#postAnchor_99ProbsPython_1to10_ToC">Back to table of contents...</a></p>




<h2>Change log</h2>


<ul>
<li>2008-04-03: Added <code>itertools.groupby()</code> versions of problems 8, 9, 10 after some more helpful comments. Added this change log.</li>
<li>2008-04-01: Added non-<code>enumerate</code> version for problem 8 after getting some helpful comments.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Writing beautiful tests (from Beautiful Code)]]></title>
    <link href="http://davesquared.net/2007/09/writing-beautiful-tests-from-beautiful.html"/>
    <updated>2007-09-13T13:25:00+10:00</updated>
    <id>http://davesquared.net/2007/09/writing-beautiful-tests-from-beautiful</id>
    <content type="html"><![CDATA[<p>Alberto Savoia's contribution to the O'Reilly-published <a href="http://beautifulcode.oreillynet.com/">Beautiful Code</a> is about writing <a title="beautiful tests" href="http://www.junitfactory.com/articles/beautiful-code/">beautiful tests</a>. The chapter is <a title="available online" href="http://www.junitfactory.com/articles/beautiful-code/">available online</a> and features a walk-through of testing a binary search implementation in Java.</p>


<p> <p>This might be a good TDD exercise -- test drive the implementation and then compare notes/tests with Alberto's article.</p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A workbook for practicing test-driven design]]></title>
    <link href="http://davesquared.net/2007/06/workbook-for-practicing-test-driven.html"/>
    <updated>2007-06-27T07:29:00+10:00</updated>
    <id>http://davesquared.net/2007/06/workbook-for-practicing-test-driven</id>
    <content type="html"><![CDATA[<p>Brian Marick has a draft&nbsp;<a title="Exploration Through Example &raquo; Blog Archive &raquo; A workbook for practicing test-driven design (draft)" href="http://www.exampler.com/blog/2007/06/26/a-workbook-for-practicing-test-driven-design-draft/">exercise</a>&nbsp;available for learning TDD. The workbook starts off with some basic requirements and an overview of the classes and test fixtures you will need. It then gets the reader to implement a number of changes, test first, presumably to illustrate the relative ease of modifying test driven code.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Blog series on building an object-relational layer using TDD]]></title>
    <link href="http://davesquared.net/2007/03/blog-series-on-building-object.html"/>
    <updated>2007-03-19T10:39:00+11:00</updated>
    <id>http://davesquared.net/2007/03/blog-series-on-building-object</id>
    <content type="html"><![CDATA[<div xmlns='http://www.w3.org/1999/xhtml'>Jeff Langr has a series of blog posts called the <a href='http://langrsoft.com/dbtdd.shtml'>Database TDD Blog Series</a>. To date there are 28 posts for this series, which walks through the creating data access code using TDD and Java. In his introduction Jeff mentions that he uses this as a repeated exercise, in the same vein as the <a href='http://www.xprogramming.com/xpmag/acsBowling.htm'>TDD bowling kata</a>.</div>

]]></content>
  </entry>
  
</feed>
