<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: python | dave^2 = -1]]></title>
  <link href="http://davesquared.net/categories/python/atom.xml" rel="self"/>
  <link href="http://davesquared.net/"/>
  <updated>2022-10-15T16:55:10+11:00</updated>
  <id>http://davesquared.net/</id>
  <author>
    <name><![CDATA[David Tchepak]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Functional programming newbie and something something monad something]]></title>
    <link href="http://davesquared.net/2011/08/functional-programming-newbie-and.html"/>
    <updated>2011-08-16T01:30:00+10:00</updated>
    <id>http://davesquared.net/2011/08/functional-programming-newbie-and</id>
    <content type="html"><![CDATA[<p>Let me get one thing straight: I know absolutely nothing about monads. I have never <a href="http://devhawk.net/2008/07/30/monadic-philosophy-part-2-the-linq-monad/">intentionally used something I've recognised as a monad</a>. I am dangerously unqualified to enhance your understanding of monads in any way. In fact <em><b>reading this may damage you and prevent you from ever learning what a monad actually is!!!</b></em></p>




<p>The first reason I'm posting anything about monads at all is that I watched one of <a href="http://www.ndc2011.no/index.aspx?cat=1070&amp;id=1300">Robert "Uncle Bob" Martin's entertaining NDC 2011 talks</a> titled "WTF is a monad" (<a href="http://www.ndc2011.no/index.aspx?id=361621&amp;cat=1069">video available from the NDC site</a>). I'm unsure how approximated or mathematically correct he was intending the presentation to be, but I found it really interesting and was able to implement something I can only hope was vaguely monadic based on my interpretation of the information he presented. So I thought I'd share it with you in case you could correct me (it should go without saying, but any mistakes here are mine and have nothing to do with Bob or his presentation). Worst case is it gets you interested enough to look into the topic and find out all the stuff I got wrong. (<a href="https://twitter.com/#!/TheColonial/status/100725544697593859">Was that alright OJ?</a> ;))</p>




<p>The second reason is that I like writing words like monad, monadic, and monoid because for a brief, shining moment it makes me feel like a real computer scientist. This moment generally comes crashing down as soon as I realise I have no idea what any of these terms mean, but it is a good couple of milliseconds. :)</p>




<p>Did I mention I don't know what I'm talking about? For this post especially I mean. Yes? Good, you should be safe to read on then...</p>




<h2>Something something monad something</h2>




<p>As far as I can gather, a <a href="http://en.wikipedia.org/wiki/Monad_(functional_programming)">monad</a> is a structure that will let you use functions that take arguments of a certain type, and apply it to values from an another type (I'll call this the <em>monadic type</em>, but I could be misusing the term). We need to be able to map back and forth between these types. Bob roughly approximates a monad to an <em>adapter</em>; a monad is a way of adapting one type to another.</p>




<p>It is the form of this adapter that makes it a monad. A monad can be expressed as two functions: the <em>unit function</em>, normally called <code>return</code> or <code>result</code>, that takes an argument of the original type and returns the monadic type; and a <code>bind</code> function that takes the monadic type and a function that works on original types. (Technically monads should also obey the <a href="http://www.haskell.org/haskellwiki/Monad_Laws">monad laws</a>. I'm sure I've missed other important points about them too, but let's run with this for now.)</p>




<p>This structure has a few useful properties, mainly to do with being able to chain a sequence of functions that take arguments of the original type, then apply arguments of the monadic type to that chain. I think.</p>




<h2>A dot monad?</h2>




<p>Uncle Bob's first example was using a monad to manipulate a dots type using functions that normally work with integers. The dots type is simply a representation of an integer using '.' characters, so 5 maps to '.....' and back again. We'd like to be able to be able to use dots with standard integer operations like <code>add</code>, so that '..' + '...' gives '.....'.</p>




<p>Let's look at an example in Python:</p>




<pre class="brush:python">
class DotMonad:
    def result(self, i):
        return '.' * i
    def bind(self, dots, f):
        return f(len(dots))
</pre>




<div class="note"><b>Aside:</b> If you haven't used Python before, the <code>self</code> arguments to the functions is required due to how instance methods work in Python. You can safely ignore them for this post, but if you know C# or Java <code>self</code> basically becomes like <code>this</code> in the context of an instance method.</div>




<p>Here our <code>result</code> function just translates integers (<code>i</code>) into dots. The <code>bind</code> function takes some dots and a function <code>f</code> that takes an integer. First it converts <code>dots</code> to integers (using the length of the string of <code>dots</code>) then calls <code>f</code> using the result.</p>




<p>This means that if we have an <code>add</code> function which takes integers, we can use our monad to adapt that function to take dots.</p>




<pre class="brush:python">
# Integer add function
def add(a, b):
    return a+b

# Monadic add function for dots
def addM(dotsA, dotsB):
    m = DotMonad()
    return m.bind(dotsA, 
        lambda a: m.bind(dotsB, 
        lambda b: m.result(a+b)
        )
    )
</pre>




<p>I've used <code>a</code> and <code>b</code> as the plain integer types, and <code>dotsA</code> and <code>dotsB</code> to represent our monadic dots type. We can now call <code>addM('..', '...')</code> and get <code>'.....'</code>.</p>




<p>So how's this work? Well remember that <code>bind</code> takes a dot for a first argument, and calls the function provided as a second argument after converting the dot to an <code>int</code>. The function we provide will be called with <code>dotsA</code> converted to integer <code>a</code>, then recursively call <code>bind</code> to convert <code>dotsB</code> in the same way. The last function in the chain is to the monad's <code>result</code> method which will convert the result of <code>a+b</code> back to dots.</p>




<p>Let's expand out and trace through the <code>addM('..', '...')</code> example to make sure we've got a handle on this:</p>




<pre class="brush:python">
return m.bind(dotsA,    # dotsA is '..', which is converted to int and passed to fn in 2nd arg
    lambda a:           # bind calls function with a = len('..'), which is 2 
        m.bind(dotsB,   # dotsB is '...', which is converted to int and passed to fn in 2nd arg
    lambda b:           # 2nd bind calls function with b = len('...'), which is 3 
        m.result(a+b)   # a+b is 2+3=5. m.result converts this back to '.....'
)
</pre>




<p>I think this is called <a href="http://www.haskell.org/haskellwiki/Lifting">lifting</a> the add (<code>+</code>) function to work with our monad.</p>




<h2>Lifting functions using monads</h2>




<p>So we've now got a version of the basic integer <code>add</code> function that can work with our monadic dots type. But we'd like to be able to apply all integer functions to work with dots. In fact, we can generalise our <code>addM</code> function from before to lift any function which takes two arguments using a monad that can bind to that function's argument type .</p>




<div class="note"><b>Aside:</b> We could also generalise to support functions with any number of arguments, but I'm struggling to keep up as it is. :\ :)</div>




<p></p>




<pre class="brush:python">
def liftm(m, op):
    return lambda a,b: m.bind(a,
            lambda ax: m.bind(b,
            lambda bx: m.result(op(ax, bx))
            )
    )
</pre>




<p>This is pretty much identical to our <code>addM</code> function, but we can now do some neat stuff. Let's import some standard Python operators and dot-erise them:</p>




<pre class="brush:python">
import operator

addM = liftm(DotMonad(), operator.add)
subM = liftm(DotMonad(), operator.sub)
divM = liftm(DotMonad(), operator.div)
mulM = liftm(DotMonad(), operator.mul)

#Interactive python session
&gt;&gt;&gt; addM('..', '.')
'...'
&gt;&gt;&gt; subM('....', '...')
'.'
&gt;&gt;&gt; divM(mulM('..', '...'), subM('...', '.'))
'...'
</pre>




<h2>Should we try again? Maybe...</h2>




<p>Let's try another monad (again, from one Bob showed in his talk). This time we're going to try and represent a type that can either have or be missing a value as a monadic type. So something very similar to .NET's <em>nullable types</em>, <code>Nullable&lt;T&gt;</code>. The difference with the monadic form is that, because of the way we chain sequences of <code>bind</code> operations, we can actually perform operations involving missing values without throwing null reference exceptions everywhere.</p>




<pre class="brush:python">
class MaybeMonad:
    def result(self, x):
        return x
    def bind(self, maybe, f):
        if (maybe is None):
            return None
        else:
            return f(maybe)
</pre>




<p>Here our <code>result</code> function just returns whatever value it is given. If it has a value it will return that value; otherwise it will return <code>None</code> (Python's <code>null</code> or <code>nil</code> value).</p>




<p>Now we can lift our standard operators to work with our <code>Maybe</code> type:</p>




<pre class="brush:python">
&gt;&gt;&gt; addm = liftm(MaybeMonad(), operator.add)
&gt;&gt;&gt; mulm = liftm(MaybeMonad(), operator.mul)
&gt;&gt;&gt; addm(2, 3)
5
&gt;&gt;&gt; addm(4, None)
&gt;&gt;&gt; mulm(6, 7)
42
&gt;&gt;&gt; mulm(None, None)
</pre>




<p>Or we can lift null-safe versions of other functions:</p>




<pre class="brush:python">
def string_lens(a, b):
    return len(a) + len(b)

#Interactive python session
&gt;&gt;&gt; string_lens("Hello", "World")
10
&gt;&gt;&gt; string_lens("Hello", None)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 2, in string_lens
TypeError: object of type 'NoneType' has no len()

&gt;&gt;&gt; safe = liftm(MaybeMonad(), string_lens)
&gt;&gt;&gt; safe("Hello", "World")
10
&gt;&gt;&gt; safe("Hello", None)
</pre>




<p>Here <code>string_lens</code> throws when we pass in <code>None</code>, but our <code>safe</code> lifted version takes them in its stride.</p>




<h2>Real-world monads</h2>




<p>Monads can actually be spotted out in the wild. They particularly enjoy frolicking with pure functional languages, where they can be used for (among other things) getting around the pesky limitation of not allowing side-effects in functions. Mutable state can be simulated by passing a State monad between functions. The I/O monad is used to encapsulate the side-effects of reading and writing from input and output.</p>




<p>Reading through the <a href="http://en.wikipedia.org/wiki/Monad_(functional_programming)#Examples">examples in the Wikipedia entry</a> shows some collections can even be regarded as monads (for example, <code>result</code> can return a list from a single item, <code>bind</code> can map a function to each element in a list). In some instances <a href="http://tomasp.net/blog/idioms-in-linq.aspx">LINQ statements can also be used as monads</a>. I've even seen <a href="http://importantshock.wordpress.com/2009/01/18/jquery-is-a-monad/">JQuery accused on monadishness</a> (yes, I just made up a word).</p>




<p>So where's this leave us? If you're like me: dazed, confused, craving a cup of tea, and also quite eager to resume working through the excellent <a href="http://learnyouahaskell.com/">Learn you a Haskell</a> tutorial. :)</p>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Getting both item and index during C# enumerations]]></title>
    <link href="http://davesquared.net/2008/08/getting-both-item-and-index-during-c.html"/>
    <updated>2008-08-30T23:55:00+10:00</updated>
    <id>http://davesquared.net/2008/08/getting-both-item-and-index-during-c</id>
    <content type="html"><![CDATA[<p>I recently got an <a href="http://davesquared.net/2008/01/python-like-range-implementation-in-c.html?showComment=1220059620000#c3630230372213218148">interesting comment</a> on an older post of mine about implementing a <a href="http://davesquared.net/2008/01/python-like-range-implementation-in-c.html">Python-like range() function in C#</a>. The commenter posed a solution to the slight feeling of disappointment experienced when you have a <code>foreach</code> loop and then realise you need to access the loop index, forcing a conversion to a <code>for</code> loop or manually incrementing a counter. The solution ended up with a syntax like this:</p>




<pre>
//From <a href="http://davesquared.net/2008/01/python-like-range-implementation-in-c.html?showComment=1220059620000#c3630230372213218148">this comment</a>:
int[] a = new int[] { 1, 2, 3, 4, 5 };
foreach (int i in Range.Array(a)) {
  // do something with i or a[i]
}
</pre>




<p>Great concept! :) Let's take it a step further by drawing some more inspiration from Python. Here's a Python list comprehension that uses the <code>enumerate()</code> function to loop over tuples of both index and item:</p>




<pre>
&gt;&gt;&gt; sampleList = ['a','b','c','d']
&gt;&gt;&gt; [(index,item) for index, item in enumerate(sampleList)]
[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd')]
</pre>




<p>Or in a more C#-like format:</p>




<pre>
&gt;&gt;&gt; for index, value in enumerate(sampleList):
     print(index, value)
 
(0, 'a')
(1, 'b')
(2, 'c')
(3, 'd')
</pre>




<p>Let's see how this could work in C#. As usual, I'll start with a test:</p>




<pre>
[Fact]
public void Can_enumerate_index_and_item() {
 String[] strings = {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;};
 int expectedIndex = 0;
 <b>foreach (var tuple in Enumerate.Over(strings)) {</b>
  Assert.Equal(expectedIndex, tuple.Index);
  Assert.Equal(strings[tuple.Index], tuple.Item);
  expectedIndex++;
 }           
}
</pre>




<p>To pass this we'll need a simple <code>Tuple</code> class (<a href="http://blogs.msdn.com/jaredpar/archive/tags/Tuple/default.aspx">better versions available</a>) and an <code>Enumerate</code> class (not entirely happy with the names, but we're just mucking around here). I'm going to violate <a href="http://en.wikipedia.org/wiki/YAGNI">YAGNI</a> guidelines here and not restrict us to just arrays of Strings.</p>




<pre>
public class Tuple&lt;T&gt; {
 public int Index { get; private set; }
 public T Item { get; private set; }

 public Tuple(int index, T item) {
  Index = index;
  Item = item;
 }
}

public class Enumerate {
 public static IEnumerable&lt;Tuple&lt;T&gt;&gt; Over&lt;T&gt;(IEnumerable&lt;T&gt; items) {
  int index = 0;
  foreach (T item in items) {
   yield return new Tuple&lt;T&gt;(index++, item);
  }  
 }
}
</pre>




<div class="note"><b>Note added 2008-10-03:</b> As a colleague of mine pointed out, this is a bit evil as it is implying <code>foreach</code> will return items in the same order as indexed. This isn't actually guaranteed at all, so you might get cases where the returned index isn't the actual index of an item.</div>




<p>The original test passes (along with a couple of others omitted for brevity), and we can now write a C# version of the Python <code>enumerate()</code> sample at the start of this post:</p>




<pre>
String[] strings = { &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; };            
foreach (var tuple in Enumerate.Over(strings)) {
 Console.WriteLine(tuple.Index + &quot;, &quot; + tuple.Item);
}
/* Outputs:
0, a
1, b
2, c
3, d
*/
</pre>




<p>I'm fairly sure there's a better (LINQ-y?) way of doing this, but this is all my Googling and I can come up with right now. :)</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[99 problems with Python (1-10)]]></title>
    <link href="http://davesquared.net/2008/03/99-problems-with-python-1-10.html"/>
    <updated>2008-03-29T22:16:00+11:00</updated>
    <id>http://davesquared.net/2008/03/99-problems-with-python-1-10</id>
    <content type="html"><![CDATA[<p>No, this is not a rant about problems I have with Python. I actually quite like it. Rather, it's my attempt to complete some of the <a href="https://prof.ti.bfh.ch/hew1/informatik3/prolog/p-99/">Dr Werner Hett's 99 Prolog logic problems</a> using Python, as a way of getting to learn a bit about the language. I first heard about the 99 Problems from <a href="http://www.frickinsweet.com/99problems/post/Starting-things-off.aspx">Joel and Ryan Lanciaux's efforts to solve the problems using F#</a>, who were in turn inspired by the <a href="http://curiouscoding.wordpress.com/2008/02/11/learning-ruby-with-ninety-nine-problems-1-10/">Ruby implementations on the Curious Coding blog</a>.</p>




<p>Keep in mind that I'm new to Python (have jumped into this exercise straight after reading the excellent <a href="https://en.wikipedia.org/wiki/Mark_Pilgrim#Dive_Into_Python">Dive into Python</a>), so much of this might be pretty clumsy. I'd love to hear any suggestions for improvements. I am also not entirely keeping with the original spirit of the Prolog exercise in terms of <a href="http://en.wikipedia.org/wiki/Logic_programming">logic programming</a>, as my main purpose is familiarising myself with Python. I have, however, tried to do things in a fairly Pythonic, <a href="http://en.wikipedia.org/wiki/Functional_programming">functional-style</a> rather than C/C++/Java/C#, <a href="http://en.wikipedia.org/wiki/Imperative_programming">imperative</a>-style. I'm also not concerned with error handling or edge cases, just in getting the basic syntax and approach right. I'm not sure I'll get through all 99 problems, but at the very least here's the first 10.</p>




<ul id="postAnchor_99ProbsPython_1to10_ToC">
<li><a href="#postAnchor_99ProbsPython_1to10_Intro">Implementation overview</a></li>
<li><a href="#postAnchor_99ProbsPython_1to10_P01">Problem 1: Find the last element of a list</a></li>
<li><a href="#postAnchor_99ProbsPython_1to10_P02">Problem 2: Find the last but one element of a list</a></li>
<li><a href="#postAnchor_99ProbsPython_1to10_P03">Problem 3: Find the K'th element of a list</a></li>
<li><a href="#postAnchor_99ProbsPython_1to10_P04">Problem 4: Find the number of elements of a list</a></li>
<li><a href="#postAnchor_99ProbsPython_1to10_P05">Problem 5: Reverse a list</a></li>
<li><a href="#postAnchor_99ProbsPython_1to10_P06">Problem 6: Find out whether a list is a palindrome</a></li>
<li><a href="#postAnchor_99ProbsPython_1to10_P07">Problem 7: Flatten a nested list structure</a></li>
<li><a href="#postAnchor_99ProbsPython_1to10_P08">Problem 8: Eliminate consecutive duplicates of list elements</a></li>
<li><a href="#postAnchor_99ProbsPython_1to10_P09">Problem 9: Pack consecutive duplicates of list elements into sublists</a></li>
<li><a href="#postAnchor_99ProbsPython_1to10_P10">Problem 10: Run-length encoding of a list</a></li>
<li><a href="#postAnchor_99ProbsPython_1to10_Conclusion">Conclusion</a></li>
</ul>




<h2 id="postAnchor_99ProbsPython_1to10_Intro">Implementation overview</h2>


<p>I did the exercise in <a href="http://www.eclipse.org/">Eclipse</a> with <a href="http://pydev.sourceforge.net/">PyDev plugin</a>, and used the Python <a href="http://docs.python.org/lib/module-unittest.html">unittest</a> module to implement each solution as a test to make it easy to run and verify each solution. You can obviously run all this using IDLE or whatever Python runner you like. Here's the basic file structure I started off with:</p>




<pre>
import unittest

class NinetyNineProblemsFixture(unittest.TestCase):
    
  def testXX_Description(self):
    def solutionToProblem(input): pass          
    input = "some input"
    expected = "expected output for successful implementation"    
    self.assertEqual(expected, solutionToProblem(input))  
  
if __name__ == '__main__':
  unittest.main()
</pre>




<p>I wrote a test for each problem, then implemented the solution as an inner function within the test. The <code>if __name__ == '__main__'</code> line lets you run the tests by simply running your *.py file through Python. I tended to run using PyTest.py from within Eclipse/PyDev.</p>




<p style="font-size: x-small"><a href="#postAnchor_99ProbsPython_1to10_ToC">Back to table of contents...</a></p>




<h2 id="postAnchor_99ProbsPython_1to10_P01">P01 Find the last element of a list</h2>


<pre>
  def test01_FindLastElementOfList(self):
    <b>def getLast(list):
      return list[-1]</b>
    list = [1, 3, 7, 14]
    self.assertEqual(14, getLast(list))
</pre>


<p>Lists are great in Python. They have lots of nice features that make them very pleasant to work with. This example shows one of these features, you can use a negative index to get list items from the end of the list. For example, <code>list[-3]</code> will get the third last item in the list. In this case, we want the last element, so we use <code>list[-1]</code>.</p>




<p style="font-size: x-small"><a href="#postAnchor_99ProbsPython_1to10_ToC">Back to table of contents...</a></p>




<h2 id="postAnchor_99ProbsPython_1to10_P02">P02 Find the last but one element of a list</h2>


<p>Same as P01, but we want the second last item:</p>


<pre>
  def test02_FindLastButOne(self):
    <b>def getLastButOne(list):
      return list[-2]</b>
    list = [1, 3, 7, 14]
    self.assertEqual(7, getLastButOne(list))
</pre>




<p style="font-size: x-small"><a href="#postAnchor_99ProbsPython_1to10_ToC">Back to table of contents...</a></p>




<h2 id="postAnchor_99ProbsPython_1to10_P03">P03 Find the K'th element of a list</h2>


<p>Basic array index for this. Lists indicies are zero-based in Python (as they should be :)), but the problem definition wants to translate the reference to 1-based.</p>


<pre>
  def test03_FindKthElement(self):
    def getKth(list, k):
      return list[k-1]
    list = [1, 3, 7, 14]
    self.assertEqual(3, getKth(list, 2))
</pre>




<p style="font-size: x-small"><a href="#postAnchor_99ProbsPython_1to10_ToC">Back to table of contents...</a></p>




<h2 id="postAnchor_99ProbsPython_1to10_P04">P04 Find the number of elements of a list</h2>


<p>Cheating for this one and just use the built in <code>len</code> function:</p>


<pre>
  def test04_NumberOfElementsInList(self):
    <b>def getCount(list):
      return len(list)</b>
    list = [1, 3, 7, 14]    
    self.assertEqual(4, getCount(list))   
</pre>




<p style="font-size: x-small"><a href="#postAnchor_99ProbsPython_1to10_ToC">Back to table of contents...</a></p>




<h2 id="postAnchor_99ProbsPython_1to10_P05">P05 Reverse a list</h2>


<p>Here I played around with two different approaches so as to learn a bit about Python list slicing.</p>




<div class="note">
<p><b>Update (2 April 2008):</b> Initially I did not realise that there was a built-in <code>reversed()</code> function. I originally had something silly like this:</p>
<pre>
    def reverse(l):
      newList = list(l)      
      return newList.reverse() or newList
</pre>

<p>The <code>list.reverse</code> function does an in-place reversal of the list elements and returns <code>None</code> (the Python null value), so I had to clone the list first so as not to affect the original, then OR it to return the list reference itself. Thanks to <a href="http://reddit.com/r/Python/info/6e168/comments/c03l8i6">Mark</a> et al. on <a href="http://reddit.com/r/Python/info/6e168/comments">Reddit</a> for showing me the light! :)</p>
</div>




<pre>
  def test05_ReverseAList(self):
    <b>def reverse(l):
      return list(reversed(aList))</b>
    <b>def manualReverse(list):          
      return list[::-1]</b>
    sampleList = [1, 3, 7, 14]
    self.assertEqual([14, 7, 3, 1], reverse(sampleList))
    self.assertEqual([14, 7, 3, 1], manualReverse(sampleList))
</pre>




<p>The <code>reversed()</code> function returns an iterator, so it is wrapped in a <code>list()</code> constructor to convert it to a new list. I used <code>l</code> for the method parameter, as I couldn't figure out how to appropriately qualify references to the <code>list</code> class when it was hidden by a parameter called <code>list</code> (cue embarrassed smiley).</p>




<h3>List slicing</h3>


<p>The second approach was to use Python's list <em>slicing</em>. A <em>slice</em> is a range of values copied from an original list. This means we have no side effects like we do using the in place <code>reverse()</code>. The basic syntax for a slice is:</p>




<pre>list[indexOfFirstElementInSlice : indexOfFirstElement_Not_InSlice : optionalStep]</pre>




<p>Omitting the first argument starts the slice from the first list element. Omitting the second argument takes the remainder of elements in the list. The step can be set to, say, 2 to take every second list element. It's worth noticing that the second argument is exclusive, so that we can the following from the Python interpreter:</p>




<pre>
&gt;&gt;&gt; aList = range(0, 6)
&gt;&gt;&gt; aList
[0, 1, 2, 3, 4, 5]
&gt;&gt;&gt; #From index 1 up to, but excluding, index 5:
&gt;&gt;&gt; aList[1:5]
[1, 2, 3, 4]
&gt;&gt;&gt; aList[1::2]
[1, 3, 5]
</pre>




<p>In our case we want the slice to include all the elements, but we want to take them in reverse order, which is how we end up with <code>list[::-1]</code>. Right, that was all a lot of explanation for not-much-code, but I thought I'd point out some Python basics along the way.</p>




<p style="font-size: x-small"><a href="#postAnchor_99ProbsPython_1to10_ToC">Back to table of contents...</a></p>




<h2 id="postAnchor_99ProbsPython_1to10_P06">P06 Find out whether a list is a palindrome</h2>


<p>A palindrome is something that reads the same forward as it does backwards, like &quot;Go hang a salami, I'm a lasagna hog&quot;* (well, ignoring punctuation and spaces). I tried two different approaches for this one too.</p>




<pre>
  def test06_IsListAPalindrome(self):
    <b>def isPalindrome(aList):
      return aList == aList[::-1]</b>
    <b>def isPalindromeRecursive(aList):
      if (len(aList)&lt;=1): return True
      top, tail = aList[0], aList[-1]          
      if (top != tail): return False
      return isPalindromeRecursive(aList[1:-1])</b>
    palindromes = [
                   ['a', 'b', 'c', 'b', 'a'],
                   [1, 10, 20, 30, 30, 20, 10, 1],
                   ['a', 'a']                    
                   ]
    nonPalindromes = [
                      ['a', 'b', 'c', 'd'],
                      [1, 10, 20, 20, 10, 2],
                      ['a', 'v']
                      ]    
    self.assertTrue(all([isPalindrome(x) for x in palindromes]))
    self.assertTrue(all([not isPalindrome(x) for x in nonPalindromes]))
    
    self.assertTrue(all([isPalindromeRecursive(x) for x in palindromes]))
    self.assertTrue(all([not isPalindromeRecursive(x) for x in nonPalindromes]))
</pre>




<p>The first way is cheating, but effective. Simply use <code>return aList == aList[::-1]</code> to compare the list with a reverse slice, using the same slicing syntax used for P05. This will obviously ensure the list reads the same forwards as backwards.</p>




<p>The second way uses recursion, as well as logical list operations to get the same effect. Let's break it down:</p>




<pre>if (len(aList)&lt;=1): return True</pre>




<p>A list of 0 or 1 elements will read the same forwards as backwards, right? So yes, we have a palindrome.</p>




<pre>top, tail = aList[0], aList[-1]          
if (top != tail): return False</pre>




<p>Ok, now we look at first and last elements of the list (the latter of which I inconveniently named <code>tail</code>, which is normally used to refer to the remainder of the list besides the first element, head/tail semantics). This line also shows how you can do multiple assignments over one line in Python. You can also use a similar syntax return multiple values from one function, which we'll see later if you make it that far without getting bored :). The second line of the fragment then compares these elements -- if they are not equal then the list can't be a palindrome (e.g. <b>1</b> 2 3 2 <b>7</b>, the 1 and 7 don't match so the list isn't a palindrome).</p>




<p>If the first and last elements <b>are</b> equal, then we have a potential palindrome, and use <a href="http://en.wikipedia.org/wiki/Tail_recursion">tail recursion</a> to check whether a slice of the list, excluding the first and last elements, is a palindrome. Which seems to work nicely.</p>




<p style="font-size: x-small">* A fine <a href="http://en.wikipedia.org/wiki/Bob_(song)">lesson in palindromes</a> is available from Mr Yankovic album. You might be able to find a version <a href="http://www.youtube.com/watch?v=Nej4xJe4Tdg">somewhere</a> without too much trouble, strictly for educational purposes.</p>




<p style="font-size: x-small"><a href="#postAnchor_99ProbsPython_1to10_ToC">Back to table of contents...</a></p>




<h2 id="postAnchor_99ProbsPython_1to10_P07">P07 Flatten a nested list structure</h2>


<p>This problem just wants us to take a nested list, like <code>[1, [2, 3], [4, 5, [6, 7]]]</code>, and flatten it out to a 1-dimensional list, like <code>[1, 2, 3, 4, 5, 6, 7]</code>. After coming up with a fairly ugly solution I ended up peeking at the <a href="http://curiouscoding.wordpress.com/2008/02/20/p07-flatten-a-nested-array-structure/">Curious Coding solution</a>, and adapted it to Python. This is also the first problem in the set marked as a 2-star problem, or &quot;intermediate difficulty&quot; (the others have all been marked as 1-star, or &quot;easy&quot;).</p>


<pre>
  def test07_FlattenAList(self):
    <b>def flatten(aList):
      flatList = []      
      for item in aList:
        if (type(item)==list):
          flatList.extend(flatten(item))
        else:
          flatList.append(item)          
      return flatList</b>
    self.assertEqual(
                     [1, 2, 3, 4, 5, 6, 7], 
                     flatten([1, [2, 3], [4, 5, [6, 7]]])
                     )
</pre>


<p>Points of note from this problem is the use of the <code>type()</code> method (well, <code>type</code> is actually a &quot;type&quot;, which, like everything in Python, is an object). This is used to check if the current element is a list. If so, the flattened list is extended by the flattened version of that sub-list (via a recursive call to <code>flatten()</code>). If not, the element is appended to the flatList.</p>




<p>The <code>extend()</code> method adds the items from a list to another list, whereas <code>append()</code> adds the item from as a single element to the list. This is probably best shown with an example:</p>




<pre>
&gt;&gt;&gt; aList = range(0,6)
&gt;&gt;&gt; aList
[0, 1, 2, 3, 4, 5]
&gt;&gt;&gt; bList = list(aList)
&gt;&gt;&gt; bList
[0, 1, 2, 3, 4, 5]
&gt;&gt;&gt; anotherList
[6, 7]
&gt;&gt;&gt; <b>aList.append(anotherList)</b>
&gt;&gt;&gt; <b>bList.extend(anotherList)</b>
&gt;&gt;&gt; aList
[0, 1, 2, 3, 4, 5, <b>[6, 7]</b>]
&gt;&gt;&gt; bList
[0, 1, 2, 3, 4, 5, <b>6, 7</b>]
</pre>




<p style="font-size: x-small"><a href="#postAnchor_99ProbsPython_1to10_ToC">Back to table of contents...</a></p>




<h2 id="postAnchor_99ProbsPython_1to10_P08">P08 Eliminate consecutive duplicates of list elements</h2>


<p>This is another 2-star, intermediate problem, but it was pretty easy to whip through using Python's <a href="http://en.wikipedia.org/wiki/List_comprehensions">list comprehensions</a>. Let's have a quick look at the list comprehension syntax first:</p>




<pre><b>[</b>itemInNewList <b>for</b> itemInNewList <b>in</b> someList <b>if</b> someConditionIsMet<b>]</b></pre>




<p>The square braces (<code>[, ]</code>) indicate we are creating a new list. In the new list we will include <code>itemInNewList</code> as an element, for the <code>itemInNewList</code> values in <code>someList</code> (or other iterable), that meet <code>someConditionIsMet</code> (the <code>if someConditionIsMet</code> is optional). Quick example:</p>




<pre>&gt;&gt;&gt; aList = range(0,6)
&gt;&gt;&gt; aList
[0, 1, 2, 3, 4, 5]
&gt;&gt;&gt; [item for item in aList if item &lt; 3]
[0, 1, 2]
</pre>




<p>All a bit LINQ-like to me (well, more correctly <a href="http://research.microsoft.com/~emeijer/Papers/LINQ20.pdf">LINQ is inspired by features in functional programming, such as monads [PDF]</a>).</p>




<p>Back to problem 8, the aim is to eliminate consecutive duplicates from a list. So we would like to create a new list by iterating over a source list, and only including elements that are not the same as the previous element.</p>


<pre>
  def test08_EliminateConsecutiveDuplicates(self):
    <b>def compress(aList):
      return [item for index, item in enumerate(aList) if index==0 or item != aList[index-1]]</b>
    sampleList = ['a','a','a','a','b','c','c','a','a','d','e','e','e','e']
    self.assertEqual(
                     ['a','b','c','a','d','e'],
                     compress(sampleList)                     
                     )
</pre>




<p>The only tricky bit with this list comprehension compared with the trivial example given above is the use of the <code>enumerate(aList)</code> function which returns two values per iteration, the <code>item</code> and the <code>index</code> of that item. We use these variables in the list comprehension condition to check whether this is the first list item (which we want to include), or if the list item duplicates the previous one (which we want to exclude).</p>




<p>I think that's awesome :)</p>




<p style="font-size: x-small"><a href="#postAnchor_99ProbsPython_1to10_ToC">Back to table of contents...</a></p>




<h3>From comments: avoiding <code>enumerate()</code></h3>


<p>Arnar <a href="http://www.blogger.com/profile/12073820949049315334">(Blogger profile link)</a> left a nice solution for this problem in the <a href="http://davesquared.net/2008/03/99-problems-with-python-1-10.html?showComment=1206981120000#c3437122901944431864">comments</a> that doesn't require the use of <code>enumerate()</code>. I've reproduced it here (updating the naming convention to match the example above):</p>




<pre>
    def compress(aList):
        return aList[:1] + [aList[i] for i in range(1, len(aList)) if aList[i-1] != aList[i]]
</pre>




<p>This first creates a list containing only the head element (<code>aList[:1]</code>), and concatenates it with a list comprehension that eliminates duplicates. Rather than using <code>enumerate()</code> to get the index and item, Arnar used <code>range(1, len(aList))</code> (which I have <a href="http://davesquared.net/2008/01/python-like-range-implementation-in-c.html">blogged about before</a>) to generate the relevant indexes and then accesses the items direct from the list.</p>




<p>The nice thing about this approach is that by starting with <code>aList[:1]</code>, we simplify the list comprehension condition I originally had (<code>if <b>index==0</b> or item != aList[index-1]</code>). I'm not sure if there is a clear advantage of using <code>enumerate()</code> or <code>range()</code> to iterate over, but it definitely gave me another way of thinking about the problem. Thanks Arnar! :)</p>




<h3>From comments: using itertools.groupby</h3>


<div class="note">This example added 3 April 2008</div>


<p>I had a number of helpful comments suggesting I use the <a href="http://docs.python.org/lib/itertools-functions.html"><code>itertools</code></a> standard Python library for a number of these examples. Thanks to <a href="http://www.blogger.com/profile/12073820949049315334">Arnar</a>, <a href="http://davesquared.net/2008/03/99-problems-with-python-1-10.html?showComment=1207152840000#c1065796923200770025">Niall</a>, <a href="http://davesquared.net/2008/03/99-problems-with-python-1-10.html?showComment=1207153740000#c8507599583786575534">Mohammad</a> and everyone else that suggested this and wrote in with examples. I originally intended to do this exercise without using any imports (well, except for <code>unittest</code>), but <a href="http://davesquared.net/2008/03/99-problems-with-python-1-10.html?showComment=1207044600000#c3670614047789933344">Arnar</a> managed to <a href="http://davesquared.net/2008/03/99-problems-with-python-1-10.html?showComment=1207078140000#c1479086697219868845">convince me</a> to stop being so silly. :)</p>


<p>The particular <code>itertools</code> function we are looking at is <code>groupby(iterable[, key])</code>. This function returns a list of tuples. The first item in the tuple is the key for a particular group, and the second is an iterator over the group itself (i.e. <code>(key, group)</code>). So how are keys specified? By default, it is the item's identity or value (so if you group [1, 1, 1, 2, 3], you will get a group of 1s, like this:</p>


<pre>
&gt;&gt;&gt; from itertools import groupby
&gt;&gt;&gt; aList = [<b>1,1,1</b>,2,3]
&gt;&gt;&gt; [<b>list(group)</b> for key, group in groupby(aList)]
[<b>[1, 1, 1]</b>, [2], [3]]
&gt;&gt;&gt; [key for key, group in groupby(aList)]
[1, 2, 3]
</pre>




<p>Note we have to import the function from the <code>itertools</code> library first using <code>from itertools import groupby</code> (<a href="http://diveintopython.org">Dive Into Python</a> has a <a href="http://diveintopython.org/object_oriented_framework/importing_modules.html">great explanation about how to import stuff</a>). As the <code>group</code> returned is an iterator over a group, we can turn it into a list using the constructor <code>list(group)</code>. The last command issue also shows what keys <code>groupby()</code> finds when no <code>key</code> argument is supplied. We can also provide <code>groupby()</code> with a function used to calculate keys:</p>




<pre>
&gt;&gt;&gt; aList
[1, 1, 1, 2, 3]
&gt;&gt;&gt; [list(group) for key, group in groupby(aList, <b>lambda x: x&lt;3</b>)]
[[1, 1, 1, 2], [3]]
</pre>




<p>Here we use a simple lambda function to sort the list into groups: those less than 3, and not. :) Armed with just enough knowledge to be dangerous, let's try and solve problem 8 again. To eliminate consecutive duplicates, all we really want to do is get the keys from the list:</p>




<pre>
  def test08_EliminateConsecutiveDuplicates(self):
    <b>def compress(aList):        
        return [key for key, group in groupby(aList)]</b>
    sampleList = ['a','a','a','a','b','c','c','a','a','d','e','e','e','e']
    self.assertEqual([<b>'a'</b>,'b','c',<b>'a'</b>,'d','e'], compress(sampleList))
</pre>




<p>And this passes nicely. But hold on a minute! How come we have duplicated keys in there? There are to <b>'a'</b> elements! I said the default keys were each item's identity, and they are both <b>'a'</b>! Why are you lying Dave? WHY?!?!</p>




<p>Ok, I'm better now. The reason is that <code>groupby()</code> is implemented using an iterator. It goes through the list picking out items in the <b>'a'</b> group, then hits <b>'b'</b>. This has a different identity, and so starts a new group. The function's iterator has now moved past the initial group of 4 <b>'a'</b> elements, and has basically completely forgotten about them, so the next time it hits an <b>'a'</b> it creates a new group. Clear as mud? Check out the <a href="http://docs.python.org/lib/itertools-functions.html#l2h-1064">documentation</a> and it should clear things up ( worked for me :) )</p>




<p style="font-size: x-small"><a href="#postAnchor_99ProbsPython_1to10_ToC">Back to table of contents...</a></p>




<h2 id="postAnchor_99ProbsPython_1to10_P09">P09 Pack consecutive duplicates of list elements into sublists</h2>


<p>Another 2 star problem, this one wants us to convert consecutive duplicates in a list into a sub-lists. The <a href="https://prof.ti.bfh.ch/hew1/informatik3/prolog/p-99/">original problem</a> says something about only packing duplicates if list contains duplicates, but the example and implementations I have seen do not seem to do this, so I'll follow convention of blindly packing each element into a sub-list.</p>




<pre>
  def test09_PackDuplicatesIntoSubLists(self):
    <b>def pack(aList):
      packedList = []
      for index, item in enumerate(aList):
        if index==0 or item != aList[index-1]:
          packedList.append([item])
        else:  
          packedList[-1].append(item)
      return packedList</b>
    
    sampleList = ['a','a','a','a','b','c','c','a','a','d','e','e','e','e']
    self.assertEqual(
                     [['a','a','a','a'],['b'],['c','c'],['a','a'],['d'],['e','e','e','e']],
                     pack(sampleList)                     
                     )
</pre>




<p>I couldn't find a nice way of doing this list comprehension style, so I resorted to a simple imperative operation. We start with an empty <code>packedList</code>, and use the nice <code>enumerate()</code> that was so useful in problem 8 to iterate over the source list. If this is the first element, or if this element is not duplicating the previous item, we will append a one element, sub-list to <code>packedList</code> (<code>packedList.append(<b>[</b>item<b>]</b>)</code>). This means that every element of <code>packedList</code> will be a list itself. This is important, because the <code>else</code> branch of this condition relies on this fact to simply add duplicate elements to the previous sub-list (<code>packedList[-1].append(item)</code>).</p>




<p>At this point I'm seriously loving how easy it is to use Python lists: slicing, list comprehensions, negative indexing etc. Test passes, so it's off to our final question for this set.</p>




<h3>From comments: another itertools.groupby alternative</h3>


<div class="note">This example added 3 April 2008.</div>


<p>As noted in the follow ups to <a href="#postAnchor_99ProbsPython_1to10_P08">problem 8</a>, a number of commenters pointed me to the <code>groupby()</code> function (see <a href="#postAnchor_99ProbsPython_1to10_P08">problem 8</a> for an explanation). We can use it here too, but this time we want the groups rather than the keys:</p>




<pre>
  def test09_PackDuplicatesIntoSubLists(self):
    <b>def pack(aList):
        return [list(group) for key, group in groupby(aList)]</b>
    sampleList = ['a', 'a', 'a', 'a', 'b', 'c', 'c', 'a', 'a', 'd', 'e', 'e', 'e', 'e']
    self.assertEqual(
                     [['a','a','a','a'], ['b'], ['c','c'], ['a','a'], ['d'], ['e','e','e','e']],
                     pack(sampleList)                     
                    )
</pre>




<p style="font-size: x-small"><a href="#postAnchor_99ProbsPython_1to10_ToC">Back to table of contents...</a></p>




<h2 id="postAnchor_99ProbsPython_1to10_P10">P10 Run-length encoding of a list</h2>


<p>This problem relates to problem 9, but instead of showing multiple elements in each sub-list, we just want a count of how many duplicates there are. Let's have a look at the test assertion to make this clearer:</p>




<pre>
    ...
    sampleList = ['a','a','a','a','b','c','c','a','a','d','e','e','e','e']
    self.assertEqual(
                     [[4,'a'],[1,'b'],[2,'c'],[2,'a'],[1,'d'],[4,'e']],
                     encode(sampleList)
                     )
</pre>




<p>First I tackled this the easy way, using copy-and-paste reuse from problem 9 and changing the action on each branch. The implementation is show below, with differences from problem 9 emphasised:</p>




<pre>
    def encode(aList):
      encodedList = []
      for index, item in enumerate(aList):
        if index==0 or item != aList[index-1]:
          <b>encodedList.append([1, item])</b>
        else:  
          <b>encodedList[-1][0] += 1</b>
      return encodedList
</pre>




<p>Here, rather than appending to sub-lists all the time, we are keeping a structure that contains the number of duplicates and the item being duplicated in each list. That worked, passing the test show above, but I also tried a less-objectional form of reuse of the <code>pack()</code> function from P09 by calling it from a list comprehension:</p>




<pre>
    def encode2(aList):
      return [<b>[len(packed), packed[0]]</b> for packed in <b>pack(aList)</b>]    
</pre>




<p>This list comprehension is making a new list from every sub-list returned by the <code>pack()</code> function. Each item is a two item list (<code>[len(packed), packed[0]]</code>). The first item is the length of the sub-list (i.e. how many duplicates we have), and the second is the first item of the sub-list (i.e. the item being duplicated). Here is the complete test:</p>




<pre>
  def test10_RunLengthEncodeList(self):    
    <b>def encode(aList):
      encodedList = []
      for index, item in enumerate(aList):
        if index==0 or item != aList[index-1]:
          encodedList.append([1, item])
        else:  
          encodedList[-1][0] += 1
      return encodedList</b>
    def pack(aList):
      packedList = []
      for index, item in enumerate(aList):
        if index==0 or item != aList[index-1]:
          packedList.append([item])
        else:  
          packedList[-1].append(item)
      return packedList
    <b>def encode2(aList):
      return [[len(packed), packed[0]] for packed in pack(aList)]</b>
      
    sampleList = ['a','a','a','a','b','c','c','a','a','d','e','e','e','e']
    self.assertEqual(
                     [[4,'a'],[1,'b'],[2,'c'],[2,'a'],[1,'d'],[4,'e']],
                     encode(sampleList)
                     )
    self.assertEqual(
                     [[4,'a'],[1,'b'],[2,'c'],[2,'a'],[1,'d'],[4,'e']],
                     encode2(sampleList)
                     )   
</pre>




<h3>From comments: yet another itertools.groupby alternative</h3>


<div class="note">This example added 3 April 2008.</div>


<p>As noted in the follow ups to <a href="#postAnchor_99ProbsPython_1to10_P08">problem 8</a> and <a href="#postAnchor_99ProbsPython_1to10_P09">problem 9</a>, I really should have been using the <code>groupby()</code> function for some of these problems (see <a href="#postAnchor_99ProbsPython_1to10_P08">here</a> for an explanation).</p>




<pre>
  def test10_RunLengthEncodeList(self):    
    <b>def encode3(aList):
      return [[len(list(group)), key] for key, group in groupby(aList)]</b>
    sampleList = ['a','a','a','a','b','c','c','a','a','d','e','e','e','e']
    self.assertEqual(
                     [[4,'a'], [1,'b'], [2,'c'], [2,'a'], [1,'d'], [4,'e']],
                     encode3(sampleList)
                    )
</pre>




<p>This is pretty similar in form to the second approach used (<code>encode2()</code>), but without having to call <code>pack</code> first.</p>




<p style="font-size: x-small"><a href="#postAnchor_99ProbsPython_1to10_ToC">Back to table of contents...</a></p>




<h2 id="postAnchor_99ProbsPython_1to10_Conclusion">Conclusion</h2>


<p>Because all the problems so far revolved around lists, an area in which Python excels, I think all of these implementations came out quite well, especially considering I have no idea what I am doing when it comes to Python (or at all, some might argue!).</p>




<p>Looking at the <a href="http://curiouscoding.wordpress.com/2008/02/11/learning-ruby-with-ninety-nine-problems-1-10/">Ruby implementations</a>, there are a number of similarities between the Python versions I came up with. To be fair, I did peek at some of the Ruby solutions for hints in keeping to a functional programming style, but my main point here is that the language differences for basic stuff <a href="http://groups.google.com/group/comp.lang.python/msg/28422d707512283">seem fairly superficial</a>. I found both the Ruby versions and the Python versions very easy to understand.</p>




<p>Perhaps because it has been many, many years since I worked with Haskell, I found the <a href="http://www.frickinsweet.com/99problems/post/Starting-things-off.aspx">F# samples from the Lanciaux brothers</a> much more difficult to understand. The language semantics are just so different. Although all of them seem more natural to me than the <a href="https://prof.ti.bfh.ch/hew1/informatik3/prolog/p-99/">original Prolog solutions</a> :-) Take a look at the solutions to problem 8 and see if you agree:</p>




<ul>
  <li><a href="https://prof.ti.bfh.ch/hew1/informatik3/prolog/p-99/p08.pl">Problem 8 in Prolog</a></li>
  <li><a href="http://curiouscoding.wordpress.com/2008/02/21/p08-eliminate-consecutive-duplicates-of-array-elements/">Problem 8 in Ruby</a></li>
  <li><a href="http://www.frickinsweet.com/99problems/post/Problem-8.aspx">Problem 8 in F#</a></li>
  <li><a href="#postAnchor_99ProbsPython_1to10_P08">Problem 8 in Python</a></li>
</ul>




<p>All in all I had a thoroughly good time using Python for this exercise, and will definitely be looking for any excuse to use it again in future. At least for this basic stuff, the language just seems so concise and easy express your intention through the syntax. If you have suggestions for improvements or find any bugs with this please leave a comment or send me an email (tchepak at gmail). [UPDATE: Thanks to all those who have helped out with comments so far!]</p>




<p style="font-size: x-small"><a href="#postAnchor_99ProbsPython_1to10_ToC">Back to table of contents...</a></p>




<h2>Change log</h2>


<ul>
<li>2008-04-03: Added <code>itertools.groupby()</code> versions of problems 8, 9, 10 after some more helpful comments. Added this change log.</li>
<li>2008-04-01: Added non-<code>enumerate</code> version for problem 8 after getting some helpful comments.</li>
</ul>

]]></content>
  </entry>
  
</feed>
