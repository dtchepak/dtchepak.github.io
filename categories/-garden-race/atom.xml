<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: +Garden Race | dave^2 = -1]]></title>
  <link href="http://davesquared.net/categories/-garden-race/atom.xml" rel="self"/>
  <link href="http://davesquared.net/"/>
  <updated>2022-10-15T16:55:10+11:00</updated>
  <id>http://davesquared.net/</id>
  <author>
    <name><![CDATA[David Tchepak]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Garden Race Pt 3: It's GUI time!]]></title>
    <link href="http://davesquared.net/2009/03/garden-race-pt-3-its-gui-time.html"/>
    <updated>2009-03-15T22:15:00+11:00</updated>
    <id>http://davesquared.net/2009/03/garden-race-pt-3-its-gui-time</id>
    <content type="html"><![CDATA[<p><i>This post is <a href="http://davesquared.net/2008/05/garden-race-series.html">part of a series</a> exploring the (very) basics of iterative development using the example of a simple <a href="http://en.wikipedia.org/wiki/Snakes_and_ladders">Snakes and Ladders</a>-like game. Links to each post in the series will be added to the <a href="http://davesquared.net/2008/05/garden-race-series.html">index page</a>.</i></p>




<p>After having a think about <a href="http://davesquared.net/2008/05/top-down-vs-bottom-up-design.html">top-down and bottom-up design</a>, I concluded that delivering complete vertical slices was more important than whether you started at the top or bottom of the slice. As most of the work in previous iterations has been closer to the bottom of our design, it now seems a good time to start writing some tests around the GUI. This work will form the basis of this iteration.</p>




<div class="note"><b><i>Confession</i></b>: I had about 3 attempts at this installment of the series over the last year or so, each time having something crop up that stopped me working on it. Some of this post may be biased by previous attempts, although with my poor memory there shouldn't be too much chance of that. :) </div>




<h2>Project status and work for iteration 3</h2>




<p>Based on the previous two iterations, all we have left from the original list is the "feature squares" (the snakes and ladders style squares):</p>




<ol>
<li><strike>A player can roll the die, and then move that many spaces along the board.</strike></li>
<li>A player that ends his or her turn on a "feature square" (a square containing a creature or obstacle), will be moved to the square connected with that feature.</li>
<li><strike>There can be 1-4 players, and each player has their turn in sequence.</strike></li>
<li><strike>A player that reaches the final square wins the game.</strike></li>
</ol>




<p>We'll leave the pending story on hold for now so we can get to the GUI bits. One thing to notice is that none of these stories, strictly speaking, demand a GUI. So let's add one, in consultation with our customers (i.e. firstborn and I):</p>


<ol start="5">
<li>Each player's position will be displayed on an 8 x 8 grid of squares.</li>
</ol>




<p>This should give us enough to get rid of the command line demo code and give the customer something closer to a usable product. It will probably be enough to fill the whole iteration as well, as we may have to revisit some of the original stories and make sure we have exposed them all through our GUI (story 1 for example). I've also managed to miss a fairly major part of story 3 -- there is currently no way to choose how many players there are in the game.</p>




<p>I think this indicates a problem with the approach so far. Imagine having to revisit every story after implementing 50 or so due to a change to the front end. One big thing we are missing that could help us avoid this are acceptance tests. If we had those, the relevant ones would fail and we could test drive out our way back to green. It could also be an indication that we have too much logic in the untested demo app. We were aware of this when we wrote the demo app though, and never intended to keep it around long enough for it to become a problem, so manually rechecking our 3 finished stories shouldn't be too big a deal.</p>




<p>Let's start off using WPF for this, as it's shiny and new (well, compared with standard WinForms), and comes standard with our current .NET 3.5 platform. We'd obviously want to do some more research if doing this for real. I've done practically nothing with WPF to date, so I'm looking forward to publicly humiliating myself throughout the remainder of this post. (Why don't my regular readers look surprised? ;))</p>




<h2>Where to start?</h2>


<p>I'd like to replace our untested demo code with tested, production code that we can use as a foundation for a GUI. We need to make sure the functionality of our original stories are exposed via the GUI, rather than the demo app. The two things that jump out at me is that we need a way for a player to roll a die, and we also need some way to indicate the end of the game. The actual rules of the game are hopefully captured in our <code>Game</code> class, so with a bit of luck we'll only need to verify our UI's interaction with that class. Then to complete our story we'll need to make sure each player's position is displayed on the game board.</p>




<p>I'd love to avoid jumping straight to an MVP-style pattern here, in favour of starting from first principles and refactoring to patterns like that when it becomes painfully obvious we need to. However I have absolutely no idea how to do that test-first, so let's try the standard route of creating a <code>GamePresenter</code> that will mediate between our <code>Game</code> model and our UI. We'll start off with the basics of rolling the die and move on from there.</p>




<h2>Rollin', rollin', rollin'</h2>




<p>What should happen when a player interacts with the view to roll the die? Well for starters our model class, <code>Game</code>, should probably be updated to reflect the fact the player is having their turn. We don't have an actual GUI button to press, but we know that we can fire off an event when a GUI button is clicked. If we add this event to a view interface, and our real GUI implements that interface, then we'll be able to write automated tests for large number of interactions with our GUI via its interface. Our GUI implementation itself should be fairly basic and concentrate on rendering and widgets rather than application logic (see the <a href="http://www.objectmentor.com/resources/articles/TheHumbleDialogBox.pdf">Humble Dialog Box</a> [PDF]).</p>




<pre>
public class GamePresenterSpec {
    [Fact]
    public void Game_should_update_when_roll_die_is_clicked() {
        var fakeGameView = MockRepository.GenerateStub&lt;IGameView&gt;();
        var fakeGame = MockRepository.GenerateMock&lt;IGame&gt;();
        var gamePresenter = new GamePresenter(fakeGameView, fakeGame);

        fakeGameView.Raise(view =&gt; view.RollClicked += null, this, EventArgs.Empty);
        fakeGame.AssertWasCalled(game =&gt; game.Roll(Arg&lt;int&gt;.Is.Anything));
    }
}
</pre>




<p>This test isn't really saying much, just that <code>game.Roll(...)</code> should be called with any argument, which is how a player currently has their turn in our model. We need to extract an <code>IGame</code> interface for this, and also create an <code>IGameView</code> and a <code>GamePresenter</code>.</p>




<pre> 
public class GamePresenter {
    public GamePresenter(IGameView view, IGame game){}
}

public interface IGameView {
    event EventHandler RollClicked;
}

public interface IGame {
    void Roll(int dieValue);
}
</pre>




<p>Our test compiles, but fails. We'll fix that now.</p>




<pre>
public class GamePresenter {
    private readonly IGame _game;
    public GamePresenter(IGameView view, IGame game) {
        _game = game;
        view.RollClicked += view_RollClicked;
    }
    void view_RollClicked(object sender, EventArgs e) {
        _game.Roll(1);
    }
}
</pre>


<p></p>

<p>Our test now passes, and as I can't see much refactoring to do, let's try the next test. Looking at what we have so far, the most obvious deficiency to me seems to be that we are just rolling 1 in the game. We really need a die roll here (1d6 :)), but that would involve random numbers running around our tests causing havoc. So let's fake a <code>DieRoller</code> that we can use to get known values during tests, and random values during the actual game.</p>




<pre>
 public class GamePresenterSpec {
    private IGameView fakeGameView;
    private IGame fakeGame;
    private IDieRoller fakeDieRoller;

    private GamePresenter CreateGamePresenterAndDependencies() {
        fakeGameView = MockRepository.GenerateStub&lt;IGameView&gt;();
        fakeGame = MockRepository.GenerateMock&lt;IGame&gt;();
        fakeDieRoller = MockRepository.GenerateStub&lt;IDieRoller&gt;();
        return new GamePresenter(fakeGameView, fakeGame, fakeDieRoller);            
    }
    /* ... snip ... */
    [Fact]
    public void Game_should_roll_value_from_die_when_roll_die_is_clicked() {
        CreateGamePresenterAndDependencies();
        int dieFace = 3;
        fakeDieRoller.Stub(die =&gt; die.Roll()).Return(dieFace);

        RaiseRollClickedEventOnView();
        fakeGame.AssertWasCalled(game =&gt; game.Roll(dieFace));
    }

    private void RaiseRollClickedEventOnView() {
        fakeGameView.Raise(view =&gt; view.RollClicked += null, this, EventArgs.Empty);
    }
}
</pre>




<p>The new test stubs out a known value for <code>IDieRoller.Roll()</code>, then makes sure that will get passed to our <code>Game</code>. I've also shown that we've extracted the common fixture setup code into a <code>CreateGamePresenterAndDependencies()</code> method, although we'd normally do this refactoring after all the tests get to green (unfortunately this stuff is surprisingly difficult to get into blog-form, so please excuse me taking some licence with presentation).</p>




<pre>
public class GamePresenter {
    private readonly IGame game;
    private readonly IDieRoller roller;

    public GamePresenter(IGameView view, IGame game, <b>IDieRoller roller</b>) {
        this.game = game;
        this.roller = roller;
        view.RollClicked += view_RollClicked;
     }

    void view_RollClicked(object sender, EventArgs e) {
        <b>game.Roll(roller.Roll());</b>
    }
}

public interface IDieRoller {
    int Roll();
}
</pre>




<p>And we're back at green. What else can we look at? Well we should probably display the result of the roll to the player. Like our <code>view.RollClicked</code> event, we'll just make our view interface have a method for setting the result of a die roll (say, <code>ShowRollResult(dieFace)</code>), and we'll let our actual GUI implementation worry about translating this message to the display.</p>




<pre>
[Fact]
public void View_should_show_result_of_roll() {
    CreateGamePresenterAndDependencies();
    int dieFace = 2;
    fakeDieRoller.Stub(die =&gt; die.Roll()).Return(dieFace);
    RaiseRollClickedEventOnView();
    fakeGameView.AssertWasCalled(view =&gt; view.ShowRollResult(dieFace));
}
</pre>




<pre>
public class GamePresenter {
    private readonly IGameView view;
    /* ... snip ... */
    void view_RollClicked(object sender, EventArgs e) {
       <b>var dieValue = roller.Roll();</b>
       game.Roll(dieValue);
       <b>view.ShowRollResult(dieValue);</b>
    }
}
</pre>




<h2>Whose turn is it anyway?</h2>


<p>Tests pass, and can't see any refactoring to do. It is probably important to show whose turn it is, so let's try that now. First up, we need to show the current player when the game is first started.</p>




<pre>
[Fact]
public void View_should_show_current_player_when_game_is_created() {
    CreateGamePresenterAndDependencies();
    var currentPlayer = 1;
    fakeGame.Stub(game =&gt; game.CurrentPlayer).Return(currentPlayer);
    fakeGameView.AssertWasCalled(view =&gt; view.SetCurrentPlayer(currentPlayer));

}
</pre>




<p>Oops, this won't work. We are using <code>CreateGamePresenterAndDependencies()</code> to create everything in one step, but then we go on to stub out the <code>game.CurrentPlayer</code> call. Let's separate the dependency creation from the creation of the subject under test.</p>




<pre>
[Fact]
public void View_should_show_current_player_when_game_is_created() {
    <b>CreateGameDependencies();</b>
    var currentPlayer = 1;
    fakeGame.Stub(game =&gt; game.CurrentPlayer).Return(currentPlayer);
    <b>new GamePresenter(fakeGameView, fakeGame, fakeDieRoller);</b>
    fakeGameView.AssertWasCalled(view =&gt; view.SetCurrentPlayer(currentPlayer));
}
</pre>




<div class="note"><b>Note:</b> this kind of mucking around with the fixture is a drawback of using a fixture-per-class style of test organisation. This seems to be how most people start TDD (myself included), but I think using a fixture-per-scenario approach (more of a BDD style) is easier to use and probably to learn from. I'm using a more BDD-like approach for my real code now, and am finding it generally makes TDD much easier. I still haven't got it right yet though, so both for that reason and for consistency I'll stick with fixture-per-class for this post.</div>




<p>To get this passing we'll need to pull up <code>Game.CurrentPlayer</code> to the <code>IGame</code> interface, then update the <code>GamePresenter</code> constructor to pass this information to the view.</p>




<pre>
public GamePresenter(IGameView view, IGame game, IDieRoller roller) {
    this.view = view;
    this.game = game;
    this.roller = roller;
    view.RollClicked += view_RollClicked;
    <b>view.SetCurrentPlayer(game.CurrentPlayer);</b>
}
</pre>




<p>That handles the start of the game, but we also need to change whose turn it is after each roll.</p>




<pre>
[Fact]
public void View_should_show_current_player_after_a_roll() {
    CreateGamePresenterAndDependencies();
    var player = 2;
    fakeGame.Stub(game =&gt; game.CurrentPlayer).Return(player);
    RaiseRollClickedEventOnView();
    fakeGameView.AssertWasCalled(view =&gt; view.SetCurrentPlayer(player));
}

/* In GamePresenter: */
void view_RollClicked(object sender, EventArgs e) {
    var dieValue = roller.Roll();
    game.Roll(dieValue);
    view.ShowRollResult(dieValue);
    <b>view.SetCurrentPlayer(game.CurrentPlayer);</b>
}
</pre>




<div class="note"><b>Ugh:</b> Looking back through my notes while I'm typing this up, I have something to the effect of &quot;Seems ugly. Using WPF, shouldn't I be binding to the ViewModel/PresentationModel?&quot;. This is fairly important -- I'm going to blatantly end up misusing WPF in this case because I'm not taking advantage of any of the nice databinding features it has. Let's press on though, if for no reason other than to point at the author and laugh at his incompetence. Maybe we can salvage what we have later on.</div>




<h2>Where am I?</h2>




<p>Ostensibly the story we are working on is to display each player's position on the grid. It should not be too hard to update each player's position after they take their turn. Because I haven't done enough of a spike to see how our view should work, let's just assume we have a <code>MovePlayerMarker(...)</code> method on the view that will handle any animation or display stuff we need.</p>




<pre>
[Fact]
public void Should_update_players_position_after_roll() {
    CreateGamePresenterAndDependencies();
    var player = 1;
    var newSquare = 10;
    var oldSquare = 5;
    fakeGame.Stub(game =&gt; game.CurrentPlayer).Return(player);
    fakeGame.Stub(game =&gt; game.GetSquareFor(player)).Return(oldSquare);
    fakeGame.Stub(game =&gt; game.GetSquareFor(player)).Return(newSquare);
    RaiseRollClickedEventOnView();

    fakeGameView.AssertWasCalled(view =&gt; view.MovePlayerMarker(player, oldSquare, newSquare));
}

/* In GamePresenter: */
void view_RollClicked(object sender, EventArgs e) {
    var dieValue = roller.Roll();
    <b>var player = game.CurrentPlayer;</b>
    <b>var startingSquare = game.GetSquareFor(player);</b>
    game.Roll(dieValue);
    view.ShowRollResult(dieValue);
    view.SetCurrentPlayer(player);
    <b>view.MovePlayerMarker(player, startingSquare, game.GetSquareFor(player));</b>
}
</pre>




<p>We are really starting to run into some of the limitations of our <code>Game</code> class now. As soon as a player rolls the die in the game, the positions and current player changed, so we need to save this information prior to calling <code>game.Roll(...)</code>. This may indicate we may have an overly intimate implementation. We need to know all kinds of stuff about the <code>Game</code> implementation to use it, which is making our  <code>view_RollClicked(...)</code> code fairly ugly as it steps through the procedure of running the game. Maybe we should instead expose a list of player positions that we could bind to instead?</p>




<p>It looks like we are due for some refactoring, but I'm not really sure how to proceed with that. Instead of letting that hold us up as we worry about all the potential solutions we could pick, let's put that off and whack up a quick view implementation and see if that helps at all.</p>




<h2>This time I'm playing to win!</h2>




<p>Before we make that final step to the GUI implementation we still need to handle one more  case from our original console app -- winning the game. Here's two tests and an implementation that passes them both (although written one at a time, of course!).</p>




<pre>
[Fact]
public void Should_show_winner_when_game_is_finished() {
    CreateGamePresenterAndDependencies();
    int player = 3;
    fakeGame.Stub(game =&gt; game.CurrentPlayer).Return(player);
    fakeGame.Stub(game =&gt; game.IsFinished).Return(true);
    RaiseRollClickedEventOnView();
    fakeGameView.AssertWasCalled(view =&gt; view.ShowWinner(player));
}

[Fact]
public void Should_disable_die_roll_when_game_is_finished() {
    CreateGamePresenterAndDependencies();
    fakeGame.Stub(game =&gt; game.IsFinished).Return(true);
    RaiseRollClickedEventOnView();
    fakeGameView.AssertWasCalled(view =&gt; view.DisableDieRolls());
}

/* In GamePresenter: */
void view_RollClicked(object sender, EventArgs e) {
    var dieValue = roller.Roll();
    var player = game.CurrentPlayer;
    var startingSquare = game.GetSquareFor(player);
    game.Roll(dieValue);
    view.ShowRollResult(dieValue);
    view.SetCurrentPlayer(player);
    view.MovePlayerMarker(player, startingSquare, game.GetSquareFor(player));
    <b>if (game.IsFinished) {
        view.DisableDieRolls();
        view.ShowWinner(player);
    }</b>
}
</pre>




<h2>The worst, most blatant misuse of WPF in history!!!1!</h2>




<p>I'm not proud of what you are about to see. In fact, I'm rarely proud of any of the crud I write on this blog, but if my normal stuff is a 2 out of 10, this is about a -30 * 10<sup>12</sup>. My local check-in comment for this stuff is &quot;Embarrassingly bad GUI using WPF controls&quot;, which is pretty accurate. I'm using WPF controls, but saying this is WPF is like wrapping a 1000 line main method in a class declaration and calling it OO. But I did promise a GUI of sorts, so let's try and get something graphical working.</p>




<div class="note"><b>Don't do this!</b> In case you missed my subtle hints throughout this post, don't repeat what you are about to see. It would be pure evil if it weren't for its lack of competence. Don't bother donning the goggles, they'll do nothing.</div>




<p>First, I've created a new <code>DaveSquared.GardenRace.Gui</code> WPF project to house this hideous monstrosity. I've created a new WPF form called <code>GardenRaceView</code>. Here's the XAML.</p>




<pre>
&lt;Window x:Class=&quot;DaveSquared.GardenRace.Gui.GardenRaceView&quot;
    xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
    xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;
    Title=&quot;GardenRaceView&quot; Height=&quot;526&quot; Width=&quot;716&quot;&gt;
    &lt;Grid&gt;
        &lt;Grid.ColumnDefinitions&gt;
            &lt;ColumnDefinition Width=&quot;528*&quot; /&gt;
            &lt;ColumnDefinition Width=&quot;166*&quot; /&gt;
        &lt;/Grid.ColumnDefinitions&gt;
        &lt;UniformGrid Name=&quot;gameBoard&quot; Rows=&quot;8&quot; Columns=&quot;8&quot; /&gt;
        &lt;Label Grid.Column=&quot;1&quot; Height=&quot;28&quot; Margin=&quot;0,12,46,0&quot; Name=&quot;currentPlayer&quot; VerticalAlignment=&quot;Top&quot;&gt;currentPlayer&lt;/Label&gt;
        &lt;Button Grid.Column=&quot;1&quot; Height=&quot;23&quot; Margin=&quot;46,46,46,0&quot; Name=&quot;rollDieButton&quot; VerticalAlignment=&quot;Top&quot; Click=&quot;rollDieButton_Click&quot;&gt;Roll&lt;/Button&gt;
        &lt;Label Grid.Column=&quot;1&quot; Height=&quot;28&quot; Margin=&quot;0,86,46,0&quot; Name=&quot;rollResult&quot; VerticalAlignment=&quot;Top&quot;&gt;rollResult&lt;/Label&gt;
        &lt;Ellipse Visibility=&quot;Hidden&quot; Name=&quot;player1Marker&quot; Stroke=&quot;Black&quot; Height=&quot;30&quot; Margin=&quot;5, 0, 0, 0&quot; HorizontalAlignment=&quot;Left&quot; VerticalAlignment=&quot;Top&quot; Fill=&quot;Red&quot; Width=&quot;30&quot; /&gt;
        &lt;Ellipse Visibility=&quot;Hidden&quot; Height=&quot;30&quot; HorizontalAlignment=&quot;Left&quot; Name=&quot;player2Marker&quot; Stroke=&quot;Black&quot; Fill=&quot;Blue&quot; VerticalAlignment=&quot;Top&quot; Width=&quot;30&quot; /&gt;
    &lt;/Grid&gt;
&lt;/Window&gt;
</pre>




<div class="separator" style="clear: both; text-align: center;">
<a href="http://davesquared.net/images/fromblogger/s1600-h-gardenRaceView-DesignView.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://davesquared.net/images/fromblogger/s400-gardenRaceView-DesignView.png" style="cursor: move;" alt="The game screen in VS 2008's design view. It looks even worse when running for real!" title="The game screen in VS 2008's design view. It looks even worse when running for real!" /></a>
</div>




<p>This gives us two columns to work with: The left hand column to hold the board, and the right hand column for status and game controls. Let's wire this thing up. Here is the xaml.cs file. This was originally wired up piece by piece, manually testing in between (we don't have automated tests for the view remember).</p>




<pre>
public partial class GardenRaceView : Window, <b>IGameView</b> {
    public GardenRaceView() {
        InitializeComponent();
        FillSquares();
        MoveToStartingPositions();
        <b>var gameModel = new Game(64, 2);
        new GamePresenter(this, gameModel, new DieRoller());</b>
    }

    private void MoveToStartingPositions() {
        MovePlayerMarker(1, 0, 0);
        MovePlayerMarker(2, 0, 0);
    }

    private void FillSquares() {                        
        for (var squareNumber=1; squareNumber &lt;= 64; squareNumber++) {
            var square = new StackPanel();
            var squareLabel = new Label();                
            squareLabel.Content = squareNumber;
            square.Children.Add(squareLabel);
            gameBoard.Children.Add(square);
        }
    }

    public event EventHandler RollClicked;

    private void OnRollClicked() {
        EventHandler rollClickedHandler = RollClicked;
        if (rollClickedHandler != null) <b>rollClickedHandler(this, EventArgs.Empty)</b>;
    }

    <b>public void ShowRollResult(int dieFace) {
        rollResult.Content = &quot;You rolled a &quot; + dieFace;
    }</b>

    <b>public void SetCurrentPlayer(int player) {
        currentPlayer.Content = &quot;Player &quot; + player + &quot;'s turn.&quot;;
    }</b>

    public void <b>MovePlayerMarker(int player, int fromSquare, int toSquare)</b> {            
        var markerForPlayer = GetMarkerForPlayer(player);
        markerForPlayer.Visibility = Visibility.Visible;
        
        var containerForMarker = (Panel) markerForPlayer.Parent;
        containerForMarker.Children.Remove(markerForPlayer);

        <b>if (toSquare &gt;= gameBoard.Children.Count) toSquare = gameBoard.Children.Count-1;</b>
        var newSquare = (StackPanel) gameBoard.Children[toSquare];
        newSquare.Children.Add(markerForPlayer);            
    }

    private Shape GetMarkerForPlayer(int player) {
        if (player == 1) { return player1Marker; }
        if (player == 2) { return player2Marker; }
        throw new ArgumentOutOfRangeException();
    }

    <b>public void ShowWinner(int winningPlayer) {
        MessageBox.Show(&quot;Player &quot; + winningPlayer + &quot; wins! Nice work!&quot;);
    }</b>

    <b>public void DisableDieRolls() {
        rollDieButton.IsEnabled = false;
    }</b>

    private void rollDieButton_Click(object sender, RoutedEventArgs e) {
        <b>OnRollClicked();</b>
    }
}
</pre>




<p>If you haven't been blinded yet, the first thing you'll have seen is that we make our form implement our <code>IGameView</code>. The majority of these implementations are trivial: <code>ShowRollResult(...)</code>, <code>SetCurrentPlayer(...)</code>, <code>ShowWinner(...)</code>, <code>DisableDieRolls()</code>, and firing the <code>RollClicked</code> event. The <code>MovePlayerMarker(...)</code> is fairly hideous, but it is pretty much all view-specific logic (except the highlighted code that does bound checking on the player's positions).</p>




<p>There is also some code in the constructor to fill our <code>UniformGrid</code> (in the incorrect order mind you), and then the code to instantiate our presenter and model code. I don't really see a pressing need for an IoC container here yet, do you? :)</p>




<p>The only other implementation is the pseudo-random <code>DieRoller</code> which we pass through to our presenter:</p>




<pre>
internal class DieRoller : IDieRoller {
    Random random = new Random();
    public int Roll() {
        return random.Next(1, 6);
    }
}
</pre>




<p>Somewhat surprisingly, this manages to actually work (er, well, somewhat work :)).</p>




<div class="separator" style="clear: both; text-align: center;">
<a href="http://davesquared.net/images/fromblogger/s1600-h-gardenRaceView-GameView.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="292" src="http://davesquared.net/images/fromblogger/s400-gardenRaceView-GameView.png" style="cursor: move;" width="400" alt="Screen shot from the game." title="Screen shot from the game. While WPF is meant to make beautiful GUIs easier to make than ever before, it's great to see some people still manage to produce complete garbage. On the positive side, I think this one is still better than Lotus Notes. :)" /></a></div>




<h2>On what poor, pitiful, defenseless customers has my monstrosity been unleashed?</h2>




<p>So what have we done? Besides unsubscribing from Dave's blog, we also managed to test drive a presenter and unleash a hideous GUI on our unsuspecting customers. We've done a very rough job on this story (my fault, not yours), but we are now displaying players' positions on a grid. The grid is not in the correct order for a snakes and ladders-style game (it is meant to snake around, starting at the bottom of the board and winding its way up to the top), but we can refine this later. We've also replaced our untested, console-only demo app with a tested, hideous bastardisation of WPF.</p>




<p>We've also found lots of new tasks to do. First, learn WPF. Next, refactor this to have a more useful <code>Game</code> class, and maybe change the presenter into more of a presentation model approach so we can use some WPF goodness. We also need to do something about our incomplete story about being able to play with 1 - 4 players -- at present we have 2 players hard coded in. And we also should put in some snake and/or ladder-like squares.</p>




<p>Despite the obvious problems with the current code, I'd like to try and salvage some small glimmer of positivity from this post. We managed to test drive a whole host of GUI-specific functionality, before we even had a forms project. We managed to hook in a thin view on top of that foundation that, despite being ugly, just worked. (Really it did! If I was going to start lieing to you it would have been in an attempt to hide my incompetence during the rest of the post, not for something trivial like this ;)). And last but not least -- um, no, actually they're the only positives I can think of. :)</p>




<p>I hope you can get some value from this post, even if its just a laugh or two at my expense. :) I'd love to hear your thoughts as to whether what we've got here is salvageable, and if so then how you would start evolving it in the right direction. In the meantime, I'm off to <a href="http://msdn.microsoft.com/en-us/magazine/cc785479.aspx">read up on WPF</a>.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Garden Race Pt 2: Adding multiple players]]></title>
    <link href="http://davesquared.net/2008/05/garden-race-pt-2-adding-multiple.html"/>
    <updated>2008-05-18T23:43:00+10:00</updated>
    <id>http://davesquared.net/2008/05/garden-race-pt-2-adding-multiple</id>
    <content type="html"><![CDATA[<p><i>This post is <a href="http://davesquared.net/2008/05/garden-race-series.html">part of a series</a> exploring the (very) basics of iterative development using the example of a simple <a href="http://en.wikipedia.org/wiki/Snakes_and_ladders">Snakes and Ladders</a>-like game. Links to each post in the series will be added to the <a href="http://davesquared.net/2008/05/garden-race-series.html">index page</a>.</i></p>




<p>Um, ok, so the customers (firstborn and I) weren't overly impressed with the demo from <a href="http://davesquared.net/2008/05/garden-race-pt-1-snakes-ladders-and.html">part 1</a>. It did help illustrate the most pressing deficiencies though:</p>




<ul>
<li>Doesn't support multiple players</li>
<li>Doesn't have anything even remotely resembling snakes or ladders, let alone fairies</li>
<li>No gui</li>
</ul>




<p>Our story list currently looks like this:</p>




<ol>
<li><strike>A player can roll the die, and then move that many spaces along the board.</strike></li>
<li>A player that ends his or her turn on a "feature square" (a square containing a creature or obstacle), will be moved to the square connected with that feature.</li>
<li>There can be 1-4 players, and each player has their turn in sequence.</li>
<li><strike>A player that reaches the final square wins the game.</strike></li>
</ol>




<p>There are no GUI stories currently defined, but we'll need <i>something</i> resembling a GUI eventually. I am tempted to start working on some GUI stories, because I don't want to get too far through the code and then find that it won't play nice with a graphical interface. It is really the main point of this software after all. On the other hand, the <code>Game</code> class is still very basic, so maybe it would be a good idea to knock over one of the original stories on our list. Story 2 seems like it could tie in with the GUI pretty strongly -- the view will have to show the player's move, then perform some kind of animation in the <i>event</i> that the player lands on a feature square. How about Story 3? Pretty basic, and essential to the game. At least that way firstborn and I can race each other to the end of the command line demo :)</p>




<p>I'll just check with the customers... be right back.</p>




<p>Ok, customer is asleep, so I'll take that as &quot;that's fine Dad&quot; :)</p>




<p>Quick aside, normally we would estimate &quot;points&quot; or some other unit of how much effort each story would take, and how many units could be done in an iteration, then have the customer prioritise the stories for this iteration.</p>




<h2>Our test list</h2>




<p>What tests could we write for multiple players?</p>




<ol>
<li>Should be able to set the number of players for a new game</li>
<li>For a new, 2 player game, both player's should be off-the-board (square 0)</li>
<li>After first player's roll, current player should be player 2</li>
<li>After first player's roll, current player's position should be off-the-board (square 0)</li>
<li>First player rolls a 3, second player rolls a 2, then current player should be player 1 on square 3.</li>
</ol>




<p>Frankly, I don't really like how these look. Implementation details keep coming to mind, and I want to ignore them and focus on <i>what</i> I want to achieve (not <i>how</i> I want to achieve it). Let's start with these anyway and we'll see how it goes.</p>




<h2>Starting iteration 2</h2>


<p>Running all our tests shows we are all green, and all good to go. The first test on the list looks easy -- set the number of players in the game. Let's do that one.</p>




<pre>//From GameSpec.cs
[Fact]
public void Should_be_able_to_create_2_player_game() {
 var twoPlayerGame = new Game(10, 2);
 Assert.Equal(2, twoPlayerGame.NumberOfPlayers);
}
//From Game.cs
public int NumberOfPlayers { get { return numberOfPlayers; } }
public Game(int boardSize) {
 this.boardSize = boardSize;
}
public Game(int boardSize, int numberOfPlayers) {
 this.boardSize = boardSize;
 this.numberOfPlayers = numberOfPlayers;
}</pre>




<p>What about the previous constructor that just takes the <code>boardSize</code>? Well that should probably just start a new one player game I guess. Let's write a test for how we think it should work.</p>




<pre>[Fact]
public void New_game_should_have_1_player_by_default() {
 var onePlayerGame = new Game(10);
 Assert.Equal(1, onePlayerGame.NumberOfPlayers);
}</pre>




<p>This fails because the number of players initialises to zero.</p>




<pre>
public Game(int boardSize) {
 this.boardSize = boardSize;
 this.numberOfPlayers = 1;
}</pre>




<p>Fixed. Now let's look at test 2, checking the position of each player for a new game.</p>




<pre>//From GameSpec.cs:
[Fact]
public void New_game_should_start_all_players_off_the_board() {
 var newThreePlayerGame = new Game(10, 3);
 var players = new[] {1, 2, 3};
 foreach (var player in players) {
  Assert.Equal(0, newThreePlayerGame.GetSquareFor(player));   
 }            
}

//From Game.cs:
public int GetSquareFor(int player) {
 return 0;
}</pre>




<p>An obviously deficient implementation like this <code>GetSquareFor()</code> method suggests we need to writes some more tests to flesh out a better one.</p>


<p></p>

<pre>[Fact]
public void Positions_should_be_correct_after_first_two_players_roll() {
 var threePlayerGame = new Game(10, 3);
 const int firstRoll = 3;
 const int secondRoll = 5;
 
 threePlayerGame.Roll(firstRoll);
 threePlayerGame.Roll(secondRoll);
 
 Assert.Equal(firstRoll, threePlayerGame.GetSquareFor(1));
 Assert.Equal(secondRoll, threePlayerGame.GetSquareFor(2));
 Assert.Equal(0, threePlayerGame.GetSquareFor(3));
}</pre>


<p></p>

<p>Now we are potentially looking at a bigger step. We need <code>Roll()</code> to affect only the position of the current player. We don't have the concept of a current player. We'll also probably need an array or similar structure to store each player's position. <code>Roll()</code> will then store update the position of the current player, and change the current player to the next player. The <code>CurrentSquare</code> implementation will probably need to change to refer to the current player too. And then we'll have to add code to change the position in the event the player lands on a feature square! Argh!</p>




<h2>Stop worrying! Try baby steps...</h2>




<p>Let's back up a bit. I'm fairly confident we can write up the code above, but it will only be covered by one test and we are touching a lot of the <code>Game</code> class without direct guidance from the tests. We still have this test on our test list: "<i>After first player's roll, current player should be player 2</i>". This deals with the concept of the current player without requiring addition position arrays. It should only affect the <code>Roll()</code> implementation. Let's skip our last test by updating the attribute to <code>[Fact(Skip="Too big a step for now")]</code> (I could delete the test and rewrite it if we need it, but it did illustrate our need to deal with the current player concept, so I'll leave it for now). I started off coding our new test with two separate assertions:</p>




<pre>var newTwoPlayerGame = new Game(10, 2);
Assert.Equal(1, newTwoPlayerGame.CurrentPlayer);
newTwoPlayerGame.Roll(2);
Assert.Equal(2, newTwoPlayerGame.CurrentPlayer);</pre>




<p>The split asserts are ugly, and we can split this into two more specific tests. Here's the passing code, which was written one step at a time (not shown is chaining the <code>Game(int)</code> constructor to <code>Game(int, int)</code>, so everything gets initialised properly in either case. Check the download at the end for the finished code):</p>




<pre>//From GameSpec.cs:
[Fact]
public void Current_player_for_new_game_should_be_player_1() {
 var newTwoPlayerGame = new Game(10, 2);
 <b>Assert.Equal(1, newTwoPlayerGame.CurrentPlayer);</b>
}
[Fact]
public void After_first_players_roll_it_should_be_the_second_players_turn() {
 var newTwoPlayerGame = new Game(10, 2);
 newTwoPlayerGame.Roll(2);
 <b>Assert.Equal(2, newTwoPlayerGame.CurrentPlayer);</b>
}
//From Game.cs:
<b>public int CurrentPlayer { get; private set; }</b>
public Game(int boardSize, int numberOfPlayers) {
 this.boardSize = boardSize;
 this.numberOfPlayers = numberOfPlayers;
 this.playerPositions = new int[numberOfPlayers];
 <b>this.CurrentPlayer = 1;</b>
}
public void Roll(int dieValue) {
 CurrentSquare += dieValue;
 <b>CurrentPlayer++;</b>
}</pre>




<p>Before we go back to the test we skipped, I'd like to flesh out more of the <code>CurrentPlayer</code> property. Fifth test on our list was &quot;<i>First player rolls a 3, second player rolls a 2, then current player should be player 1 on square 3</i>&quot;. Let's do a simpler version and just verify that this scenario ends up with the correct <code>CurrentPlayer</code>.</p>




<pre>//In GameSpec.cs:
[Fact]
public void After_all_players_have_had_a_turn_it_should_be_first_players_turn_again() {
 var newThreePlayerGame = new Game(10, 3);
 newThreePlayerGame.Roll(1);
 newThreePlayerGame.Roll(1);
 newThreePlayerGame.Roll(1);
 Assert.Equal(1, newThreePlayerGame.CurrentPlayer);
}
//In Game.cs:
public void Roll(int dieValue) {
 CurrentSquare += dieValue;
 CurrentPlayer++;
 <b>if (CurrentPlayer > NumberOfPlayers) CurrentPlayer = 1;</b>
}
</pre>




<h2>A quick refactor from the green bar</h2>


<p>We now have a green bar (well, yellow if you count the skipped test I guess). Time to take a look for potential refactoring opportunities. I've been a bit slack about this up to now as I haven't noticed anything obvious while coding and haven't explicitly stopped to think about refactoring. I have a bad habit of doing this -- I do design work while writing the code to pass the test, rather than deferring it to the refactoring stage. This can lead me to generalising to early or changing the design without getting clear direction from the tests and passing implementation. Note to self: premature generalisation is one of the many roots of all evil :)</p>




<p>In this case we've done the Right Thing<sup>TM</sup> and written simple code to pass the test, then looked at refactoring based on what the current implementation needs, rather than what we <i>think</i> it will need. The code within <code>Roll()</code> contains the logic for selecting the next player as well as for updating the current square. Let's <a href="http://www.refactoring.com/catalog/extractMethod.html">Extract Method</a> to make this more obvious.</p>




<pre>public void Roll(int dieValue) {
 CurrentSquare += dieValue;
 <b>nextPlayer();</b>
}
private void nextPlayer() {
 CurrentPlayer++;
 if (CurrentPlayer > NumberOfPlayers) CurrentPlayer = 1;
}</pre>




<p>This is purely a matter of taste. I find it reflects the intention more. If you don't, then leave it un-refactored. :-) Either way, key lesson here (for me, you probably know it already :)) is to defer design stuff until the production code shows a clear need, or until a test is too hard to write. Either way, design from the green bar whenever possible.</p>




<h2>Time to face the music...</h2>




<p>We probably shouldn't put it off any longer. Let's re-enable the test we skipped earlier:</p>




<pre>//In GameSpec.cs:
[Fact]
public void Positions_should_be_correct_after_first_two_players_roll() {
 var threePlayerGame = new Game(10, 3);
 const int firstRoll = 3;
 const int secondRoll = 5;
 
 threePlayerGame.Roll(firstRoll);
 threePlayerGame.Roll(secondRoll);
 
 Assert.Equal(firstRoll, threePlayerGame.GetSquareFor(1));
 Assert.Equal(secondRoll, threePlayerGame.GetSquareFor(2));
 Assert.Equal(0, threePlayerGame.GetSquareFor(3));
}</pre>




<p>This give the following assertion failure:</p>


<pre>TestCase 'DaveSquared.GardenRace.Tests.GameSpec.Positions_should_be_correct_after_first_two_players_roll'
failed: Assert.Equal() Failure
Expected: 3
Actual:   0</pre>




<p>This is failing because our implementation for <code>GetSquareFor(...)</code> stinks -- it's just returning 0. My fault, not yours. Let's get back to the green bar as soon as possible, then we'll worry about getting the design right. My original guess for passing this test was that we would need an array of player positions, and <code>Roll()</code> would just update the position for the current player. We have a current player concept in the code now, so let's chuck in an array and see how it goes:</p>




<pre>//Bits and pieces from Game.cs:
public class Game {
    //...
 private readonly int[] playerPositions;
 //...
 public Game(int boardSize, int numberOfPlayers) {
  this.boardSize = boardSize;
  this.numberOfPlayers = numberOfPlayers;
  <b>this.playerPositions = new int[numberOfPlayers];</b>
  this.CurrentPlayer = 1;
 }
 public void Roll(int dieValue) {
  CurrentSquare += dieValue;
  <b>playerPositions[CurrentPlayer - 1] = CurrentSquare;</b>
  nextPlayer();
 }
 //...
 public int GetSquareFor(int player) {
  <b>return playerPositions[player - 1];</b>
 }
}</pre>




<p>Running this fails with a new message:</p>




<pre>TestCase 'DaveSquared.GardenRace.Tests.GameSpec.Positions_should_be_correct_after_first_two_players_roll'
failed: Assert.Equal() Failure
Expected: 5
Actual:   8</pre>




<p>It is failing on our second assertion, <code>Assert.Equal(secondRoll, threePlayerGame.GetSquareFor(2));</code>. This gives us a good hint as to what's happening -- our first and second rolls of 3 and 5 are both being added to the same array index. Hold on, that's only half the story. Let's have a closer look at this:</p>




<pre>public void Roll(int dieValue) {
 <b>CurrentSquare += dieValue;</b>
 playerPositions[CurrentPlayer - 1] = <b>CurrentSquare;</b>
 nextPlayer();
}</pre>




<p>Brilliant Dave. What a fantastic coder I am :) I'm still adding all rolls to <code>CurrentSquare</code>, then assigning that to the current player position. In this case, <code>CurrentSquare</code> is 3+5=8 which fails our test. Why didn't you point this out? Luckily I had my tests to do it in your absence :) We'll fix it right now:</p>




<pre>public void Roll(int dieValue) {
 CurrentSquare += dieValue;
 <b>playerPositions[CurrentPlayer - 1] += dieValue;</b>
 nextPlayer();
}</pre>




<p>Tests pass. My own ineptitude aside, this test that was initially giving us troubles has been trivial to solve. We now have a green bar, so let's refactor. First obvious bit of duplication is the two square increments in the <code>Roll()</code> method. Let's update <code>CurrentSquare</code> to use our <code>GetSquareFor(int player)</code> method:</p>




<pre>
public int CurrentSquare { 
 get { <b>return GetSquareFor(CurrentPlayer);</b> } 
}
//...
public void Roll(int dieValue) {
 playerPositions[CurrentPlayer - 1] += dieValue;
 nextPlayer();
}</pre>




<p><code>CurrentSquare</code> is no longer a getter/setter, but is a convenient shorthand for <code>GetSquareFor(int player)</code>. Our <code>Roll()</code> method is fairly clear. We could make it a little bit clearer by extracting a <code>moveCurrentPlayer(int squares)</code> method, but would also mean more indirection. I'll make you a deal, if we end up with a few <code>playerPositions[CurrentPlayer - 1]</code> style array indexes (the -1 is pretty ugly), then we do something about it. For now it is probably ok.</p>




<p>Looking at <code>Game</code> from the perspective of the <a href="http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod">S.O.L.I.D. principles</a>, I think the main one we have to be wary of is violating the <a href="http://en.wikipedia.org/wiki/Single_responsibility_principle">Single Responsibility Principle (SRP)</a>. Current <code>Game</code> is responsible for:</p>




<ul>
<li>Number of squares on the board</li>
<li>Number of players</li>
<li>Keeping track of whose turn it is</li>
<li>Keeping track of each player's position</li>
<li>Knowing when the game has finished</li>
</ul>




<p>Are these cohesive enough to count under the banner of one responsibility? I'm not sure, but I can't currently think of a better abstraction (feel free to leave comments :-)). For now let's stay conscious of this and we'll revisit it if it starts becoming a problem.</p>




<h2>We're done? No we're not!</h2>


<p>So are we done for our multiple players story? After running a larger test it appears so. However, after updating the demo we see some strange behaviour. An extract of from the demo code and the output are shown below:</p>




<pre>//From main() in Program.cs:
const int numberOfSquares = 20;
const int numberOfPlayers = 2;
//...
Console.WriteLine(&quot;Creating a new game with &quot; + numberOfSquares + &quot; squares and &quot; + numberOfPlayers + &quot; players.&quot;);
var game = new Game(numberOfSquares, numberOfPlayers);
Console.WriteLine(&quot;Press any key to roll the die.&quot;);
while (!game.IsFinished) {
 Console.ReadKey(interceptKey);
 var dieRoll = GetDieValue();
 <b>game.Roll(dieRoll);</b>
 var currentState = (game.IsFinished) ? &quot;You won the game!&quot; : &quot;Now on square &quot; + game.CurrentSquare;
 Console.WriteLine(&quot;Player &quot; + game.CurrentPlayer + &quot; rolled a &quot; + dieRoll + &quot;. &quot; + currentState);
}
//...</pre>




<pre>Creating a new game with 20 squares and 2 players.
Press any key to roll the die.
<b>Player 2 rolled a 1. Now on square 0</b>
Player 1 rolled a 3. Now on square 1
Player 2 rolled a 2. Now on square 3
...snip...
Player 2 rolled a 2. Now on square 18
Player 1 rolled a 2. Now on square 14
Player 2 rolled a 3. You won the game!</pre>




<p>Why does player 2 have the first go? And why do they roll a 1 and yet are on square 0? The reason is highlighted in the code snippet above -- the <code>Roll()</code> method updates the Game so that it is the next player's turn. When the demo gets to writing out the current player's position and state, it is actually writing the details for the next player who is about to have their turn.</p>




<p>I believe this is a form of <i>temporal coupling</i>, or coupling in time. The <code>CurrentSquare</code> and <code>CurrentPlayer</code> methods depend on whether they are called before or after <code>Roll</code>. There is almost certainly going to be a problem with <code>IsFinished</code> as well, as that depends on the <code>CurrentPlayer</code> too.</p>




<p>I've been worried about this for a little while actually, especially when thinking about how the GUI will probably want to animate the initial move, then an additional move up or down the snake/ladder/critter type thing. It looks like we'll either have to trigger events from <code>Roll</code>, or break it up and have some kind of coordinator object.</p>




<p>I am quietly confident that we can change our design to support this when we get some tests around the &quot;feature square&quot; or GUI stories, and that these tests will drive us toward a decent design and implementation. Again, let's stay conscious of this coupling and work around it in our demo code. Remember that our demo code is not production code, so we are being a little less precious with it. Next iteration we'll make sure we write tests to cover this and drive a nicer design.</p>




<p>Here's the new main loop in the demo code:</p>




<pre>
while (!game.IsFinished) {
 var currentPlayer = game.CurrentPlayer;
 Console.ReadKey(interceptKey);
 var dieRoll = GetDieValue();
 game.Roll(dieRoll);
 var currentState = (<b>game.IsFinished</b>) ? &quot;You won the game!&quot; : &quot;Now on square &quot; + game.GetSquareFor(currentPlayer);
 Console.WriteLine(&quot;Player &quot; + currentPlayer + &quot; rolled a &quot; + dieRoll + &quot;. &quot; + currentState);
}
</pre>




<pre>Creating a new game with 20 squares and 2 players.
Press any key to roll the die.
Player 1 rolled a 5. Now on square 5
Player 2 rolled a 3. Now on square 3
(...snip...)
Player 2 rolled a 1. Now on square 10
Player 1 rolled a 5. <b>Now on square 23</b>
Player 2 rolled a 5. You won the game!
</pre>




<p>As predicted, our <code>IsFinished</code> property is having problems because of the coupling issue. We'll fix this, then we're done.</p>




<h2>Test-first debugging</h2>




<p>Let's write a test to expose the bug with the <code>IsFinished</code> implementation:</p>




<pre>[Fact]
public void Game_should_finish_as_soon_as_any_player_reaches_the_end() {
 var threePlayerGame = new Game(5, 3);
 threePlayerGame.Roll(1);
 threePlayerGame.Roll(6);
 Assert.True(threePlayerGame.IsFinished);
}</pre>




<p>This fails. At the time the assertion is evaluated player 2 has finished, but the current player is player 3, who is yet to finish. This should be straight-forward to pass from here:</p>




<pre>public bool IsFinished {
 get {
   return <b>playerPositions.Any(square => square >= boardSize)</b>;
 }
}</pre>




<p>All the tests now pass. We've now removed the temporal coupling between <code>Roll</code> and <code>IsFinished</code>, and our demo now works as expected:</p>




<pre>Creating a new game with 20 squares and 2 players.
Press any key to roll the die.
Player 1 rolled a 1. Now on square 1
Player 2 rolled a 1. Now on square 1
(...snip...)
Player 1 rolled a 2. Now on square 17
Player 2 rolled a 2. Now on square 15
Player 1 rolled a 3. You won the game!

Press a key to exit.
</pre>




<h2>That's a wrap!</h2>


<p>Not sure if this looks like a lot of work to you, but it actually represents only a couple of minutes of coding time, and a couple of minutes of thinking time (plus lots of time to write it all down in excruciating detail :-)). Point is that each iteration so far has been really quick despite (or because of?) involving lots of small steps.</p>




<p>You can browse or checkout the final code for this iteration from <a href="http://code.google.com/p/davesquared/source/browse/DaveSquared.GardenRace/tags/part2">here</a>. Thanks for making it this far! :)</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Garden Race Pt 1: Snakes, ladders and iterations]]></title>
    <link href="http://davesquared.net/2008/05/garden-race-pt-1-snakes-ladders-and.html"/>
    <updated>2008-05-16T00:04:00+10:00</updated>
    <id>http://davesquared.net/2008/05/garden-race-pt-1-snakes-ladders-and</id>
    <content type="html"><![CDATA[<p><i>This post is <a href="http://davesquared.net/2008/05/garden-race-series.html">part of a series</a> exploring the (very) basics of iterative development using the example of a simple <a href="http://en.wikipedia.org/wiki/Snakes_and_ladders">Snakes and Ladders</a>-like game. Links to each post in the series will be added to the <a href="http://davesquared.net/2008/05/garden-race-series.html">index page</a>.</i></p>




<p>For a while now I've wanted to write a <a href="http://en.wikipedia.org/wiki/Snakes_and_ladders">Snakes and Ladders</a>-style game for my daughter, both to be a nice nerdy Dad, and to practice some dev stuff. I was going to create &quot;Warps and Wormholes&quot;, but firstborn was adamant she wanted fairies involved. And so I've ended up with &quot;Garden Race&quot;, which is going to be a race for players to make it to one end of the garden aided by fairies, butterflies and other girlie stuff, while hindered by lizards, hoses, and other less-girlie stuff.</p>




<p>I intend to use iterative development for this project -- I'll start off with a thin slice of functionality and keep adding to it to build up a semi-usable game. This should accomplish two things: first, showcase my own ineptitude, and second, to help improve my TDD and development skills. While I'm not exactly sure how far I'll get with this project (free time is short at present), I can commit to being fairly honest during this process. If and when I stuff up, I'll write it down (I might excuse myself a quick spike here and there so the posts don't get bogged down to much, but the stuff ups will stay).</p>




<p>Note: MS has a <a href="http://creators.xna.com/">free game design version of Visual Studio</a> that might be useful if your aim is to make a good game for your kids (instead of just playing with dev stuff). There are also a few open source frameworks out there (like <a href="http://childsplay.sourceforge.net/docs-manifesto.php">Childsplay</a>).</p>




<p>For my starting point, I began with a rough solution structure (main Game project and a test project), chucked it in a local SVN repo, and setup some of the tools I'd need. I'm trying using a <code>/src</code> based configuration just for kicks, and might try nant just for something different. I am also trying <a href="http://www.codeplex.com/xunit/">XUnit.Net</a>, instead of my usual NUnit test framework.</p>




<h2>Requirements</h2>


<p>Our customers, i.e. my firstborn (after some prompting) and I, want a Snakes and Ladders-type game involving fairies and other garden-dwelling folk. Here is the basic statement of what we want:</p>




<blockquote>&quot;Garden Race is a computer-based board game. Players take it in turns to roll a die, and then move the corresponding number of squares on the board. If the player lands on a square featuring a garden creature of obstacle at the end of their turn, then that creature or obstacle will move the player to a connected square on the board. The first player to reach the bottom of the garden (the end of the board) wins. We want fancy 3D graphics, surround sound, and it has to be ready yesterday.&quot;</blockquote>




<p>Ever noticed how hard it is to succinctly describe a simple concept, even something as simple as this? Let's try and remove some ambiguity by boiling things down into user stories.</p>




<ol>
<li>A player can roll the die, and then move that many spaces along the board.</li>
<li>A player that ends his or her turn on a "feature square" (a square containing a creature or obstacle), will be moved to the square connected with that feature.</li>
<li>There can be 1-4 players, and each player has their turn in sequence.</li>
<li>A player that reaches the final square wins the game.</li>
</ol>




<p>That should probably be enough to get us going.</p>




<h2>Planning and design for this iteration</h2>




<p>In the spirit of iterative design we are going to first try to deliver a slice of functionality. As we are currently unsure of exactly how to present the customer with fancy 3D graphics and sound (at this stage the dev team (me) would like to try WPF or QT4, but we don't know all the requirements yet), let's focus on the core game functionality, which is pretty much captured by the user stories above.</p>




<p>For our first iteration we've agreed with the customer to deliver stories 1 and 4, which is basically a single player rolling a die and moving to the end of the board. Exciting game huh? But it should reveal some basics of how the game mechanics work, so it seems a safe place to start.</p>




<p>If we are picking nouns for potential classes in our game we might come up with <code>Player</code>, <code>Die</code>, <code>Square</code>, and <code>Board</code>, but we're definitely <a href="http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html">not going to use nouns as a basis for our design</a>. A nice place to start might just be a <code>Game</code> or <code>GameEngine</code> class. What tests could we come up with for our first story?</p>




<ul>
<li>A player should not be on the board until the roll the die and move.</li>
<li>A player that rolls a 4 should then be on the 4th square from the start.</li>
<li>A player that rolls a 2, and then a 6, should be on the 8th square from the start.</li>
<li>The game should finish once the player reaches the end.</li>
</ul>




<p>We currently don't have enough information to implement all of this. How many squares are there on the board? What is the maximum value of the die used? What happens if the player is one square from the end, and rolls a 3? The first couple of points we will check with the customer, but it doesn't really affect our design. Let's test for the last case though, and we'll check with the customer if our assumption is correct:</p>




<ul><li>A player that is one square from the end, and rolls a 3, should win the game.</li></ul>




<p>Before we jump into this iteration, I'd be really interested to hear any up-front design ideas you have for this. If you were going to draw a UML class diagram or write up some CRC cards, what classes, data and relationships would you have? I've got my own ideas, but I don't want to influence my iterative design process too much at this point, nor do I want to deliberately come up with a shoddy upfront design and then marvel at how well my iterative design (hopefully) turns out. Please feel free to leave your design ideas in the comments or email me.</p>




<p>Right, let's start.</p>




<h2>First tests</h2>




<p>Let's look at the second test on our test list. It looks like an easy thing to do and should help us learn a little about the problem domain.</p>


<pre>public class GameSpec {
    [Fact]
    public void Player_should_be_on_fourth_square_after_rolling_a_four() {
        var game = new Game();
        game.Roll(4);
        Assert.Equal(4, game.CurrentSquare);
    }
}</pre>




<p>Not going to keep much of this, I'm pretty sure of that. But we need to start somewhere. By the way, if you aren't familiar with XUnit.Net, <code>[Fact]</code> == <code>[Test]</code>. Now let's pass the test:</p>




<pre>public class Game {
    public int CurrentSquare;

    public void Roll(int dieValue) {
        CurrentSquare += dieValue;
    }
}</pre>




<p>Now let's test two rolls, which is the third test on our list.</p>




<pre>[Fact]
public void Player_should_be_on_eight_square_after_rolling_a_two_then_a_six() {
 var game = new Game();
 game.Roll(2);
 game.Roll(6);
 Assert.Equal(8, game.CurrentSquare);
}</pre>




<p>This works without change, as we jumped straight to an obvious implementation for <code>Roll()</code>. We could have taken smaller steps and initially used <code>CurrentSquare = dieValue;</code> to pass the first test, the updated it to pass the second test, but we don't need to do that unless we aren't really sure how to proceed.</p>




<p>Let's add a third test to make sure the player starts off the board, or square 0.</p>




<pre>var game = new Game();
Assert.Equal(0, game.CurrentSquare);</pre>




<p>Again, this passes without modification. We also have a test on our list about finishing the game. We don't have too much information about how this works, so let's look at what we can test.</p>




<pre>
[Fact]
public void Game_should_finish_when_player_reaches_end_of_board() {
 const int boardSize = 10;
 var game = new Game(boardSize);
 game.Roll(boardSize);
 Assert.Equal(10, game.CurrentSquare);
 Assert.True(game.IsFinished);
}</pre>




<p>This introduces two new concepts: board size, and the game state as finished or not finished. To get this to compile we need to add non-default constructor to <code>Game</code>, which means we also need to explicitly add a default constructor if we want to stop our other tests from breaking. We also need to add an <code>IsFinished</code> property to <code>Game</code>. The following implementation compiles and passes all the tests.</p>




<pre>public class Game {        
 public int CurrentSquare;
 public Game(int boardSize) {}
 public Game() {}
 public bool IsFinished {
  get { return true; }
 }
 public void Roll(int dieValue) {
  CurrentSquare += dieValue;
 }
}</pre>




<p>The <code>IsFinished</code> implementation obviously stinks, so let's also add a test around unfinished games.</p>




<pre>[Fact]
public void New_game_should_be_unfinished() {
 const int boardSize = 10;
 var game = new Game(boardSize);
 Assert.False(game.IsFinished);
}</pre>




<p>I first did a trivial implementation:</p>




<pre>public bool IsFinished {
 get { return CurrentSquare == 0; }
}</pre>




<p>Which failed both my IsFinished tests. Oops, that should be <code>CurrentSquare != 0</code>. Tests now pass, but the implementation still stinks. Let's try this one:</p>




<pre>[Fact]
public void In_progress_game_should_be_unfinished() {
 const int boardSize = 10;
 var game = new Game(boardSize);
 game.Roll(5);
 Assert.False(game.IsFinished);
}</pre>




<p>Which we can pass with this:</p>




<pre>public class Game {
 private readonly int boardSize;  
 public Game(int boardSize) {
  this.boardSize = boardSize;
 }
 public bool IsFinished {
  get { return CurrentSquare &gt;= boardSize; }
 }
 //...[snip]...</pre>




<p>The last test on our list so far is to see what happens when we overrun the last square on the board.</p>




<pre>[Fact]
public void Game_should_still_finish_when_player_overruns_last_square() {
 const int boardSize = 10;
 var game = new Game(boardSize);
 game.Roll(boardSize + 2);
 Assert.True(game.IsFinished);
}</pre>




<p>This passes because we used &gt;= for the CurrentSquare/boardSize comparison. One thing I haven't been doing is the refactor step of the TDD red-green-refactor process. Let's look at <code>Game</code>:</p>




<pre>public class Game {
 private readonly int boardSize;
 public int CurrentSquare;
 public Game(int boardSize) {
  this.boardSize = boardSize;
 }
 public Game() {}
 public bool IsFinished {
  get { return CurrentSquare &gt;= boardSize; }
 }
 public void Roll(int dieValue) {
  CurrentSquare += dieValue;
 }
}</pre>




<p>Not much to refactor there, right? The tests have some duplication in the <code>Game</code> setup though. And the default constructor of <code>Game</code> looks fairly useless. Normally I would just whack that into a <code>[SetUp]</code> method, but XUnit.Net discourages this as it can make for non-obvious test contexts. My GameSpec tests currently want to execute in the one test context -- a new <code>Game</code> with 10 squares. It seems reasonable that my GameSpec HAS-A context, so let's add a game as a field with a descriptive name. I can then replace the game initialisation in each test with a simple reference to <code>newTenSquareGame</code>, and get rid of Game's default constructor. </p>




<pre>public class GameSpec {
 private readonly Game newTenSquareGame = new Game(10);
 //...[snip]...
 [Fact]
 public void Game_should_finish_when_player_reaches_end_of_board() {
  newTenSquareGame.Roll(10);
  Assert.Equal(10, newTenSquareGame.CurrentSquare);
  Assert.True(newTenSquareGame.IsFinished);
 }
 //...[snip]...</pre>




<p>If we start having lots of different contexts or complicated contexts we may want to revisit this, but the whole test fixture reads fairly well for now. Full disclosure: before this approach I mucked around with some crazy test structure ideas I have regarding tests and test contexts. I'm omitting that from this post as it was mainly for personal interest rather that something I would normally do.</p>




<p>So what's next? Our test list is empty, and we seem to have completed most of our first iteration, stories 1 and 4. If you remember, these basically covered moving a single player around the board, and being able to finish the game. This isn't really something we can show our customer though. You don't go showing a youngin' a bunch of unit tests when they are expecting a fairyised version of Snakes and Ladders. And we haven't even dealt with the concept of &quot;rolling a die&quot;, we have just assumed a value. But we seem to have the basic functionality we promised for this iteration.</p>




<h2>Customer demo</h2>


<p>To finish this iteration, let's write a console app that will allow our customer to run through the current game logic. Here's what I'm thinking of:</p>




<pre>
  Creating new game with 20 squares.
  Press a key to roll the dice.
  You rolled a 4. Now on square 4.
  You rolled a 6. Now on square 10.
  ...
  You rolled a 2. You won the game!</pre>




<p>At first I was thinking about creating a <code>GameController</code> class and writing some tests around that, then calling that from a simple console app. But <a href="http://en.wikipedia.org/wiki/YAGNI">we don't need that yet</a>. So let's just do the simplest thing that will work for our demo. And because it is slapped together and not designed to specific requirements, let's just promise not to use any of this code in the actual product.</p>


<p> <pre>namespace DaveSquared.GardenRace.ConsoleFrontEnd {
    class Program {
        private static readonly Random random = new Random();</p>

<pre><code>    static void Main(string[] args) {
        Console.WriteLine(&amp;quot;Welcome to Garden Race! It's like Snakes and Ladders, only without the copyright violation!&amp;quot;);
        Console.WriteLine();

        const int numberOfSquares = 20;
        const bool interceptKey = true;

        Console.WriteLine(&amp;quot;Creating a new game with &amp;quot; + numberOfSquares + &amp;quot; squares.&amp;quot;);
        var game = new Game(numberOfSquares);
        Console.WriteLine(&amp;quot;Press any key to roll the die.&amp;quot;);
        while (!game.IsFinished) {                
            Console.ReadKey(interceptKey);
            var dieRoll = GetDieValue();
            game.Roll(dieRoll);
            var currentState = (game.IsFinished) ? &amp;quot;You won the game!&amp;quot; : &amp;quot;Now on square &amp;quot; + game.CurrentSquare;
            Console.WriteLine(&amp;quot;You rolled a &amp;quot; + dieRoll + &amp;quot;. &amp;quot; + currentState);
        }
        Console.WriteLine();
        Console.WriteLine(&amp;quot;Press a key to exit.&amp;quot;);
        Console.ReadKey(interceptKey);
    }

    static int GetDieValue() {
        return random.Next(1, 6);
    }
}
</code></pre>

<p>}</pre></p>

<p>A now for the moment of truth:</p>




<p><a href="http://davesquared.net/images/fromblogger/s1600-h-gardenRaceConsole.png"><img style="cursor:pointer; cursor:hand;" src="http://davesquared.net/images/fromblogger/s400-gardenRaceConsole.png" border="0" alt="Console app showing our demo" id="BLOGGER_PHOTO_ID_5200605521523294946" /></a>
</p>




<p>Fantastic! <code>Assert.That(this_game_rocks).SaidWith(sarcasm)</code>! On the other hand, it took about 12 minutes to code this iteration up as well as write out tests (plus lots of time for me to type out this narrative), and our story list made it clear when we could stop. So let's go show our customers. I'm sure they'll be impressed...</p>




<p><i><a href="http://davesquared.net/2008/05/garden-race-pt-2-adding-multiple.html">To be continued...</a></i></p>




<h2 id="GardenRacePart1-Download">Download</h2>


<p>You can browse through or download this tremendously exiting code from <a href="http://code.google.com/p/davesquared/source/browse/DaveSquared.GardenRace/tags/part1/">davesquared.googlecode.com</a>.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Garden Race Series: Basics of iterative development and TDD]]></title>
    <link href="http://davesquared.net/2008/05/garden-race-series.html"/>
    <updated>2008-05-15T22:02:00+10:00</updated>
    <id>http://davesquared.net/2008/05/garden-race-series</id>
    <content type="html"><![CDATA[<p>This page is an index page for the Garden Race series. This intention behind this series of posts is to teach myself a bit about the basics TDD and iterative development by working through an example of building a <a href="http://en.wikipedia.org/wiki/Snakes_and_ladders">Snakes and Ladders</a>-style game. Hopefully this example strikes a balance between being simple enough to write up as blog posts and being involved enough to for me to learn some things about iterative development that can translate to real work.</p>




<ul>
<li><a href="http://davesquared.net/2008/05/garden-race-pt-1-snakes-ladders-and.html">Part 1: Snakes, ladders and iterations</a> (introduction and first iteration)</li>
<li><a href="http://davesquared.net/2008/05/garden-race-pt-2-adding-multiple.html">Part 2: Adding multiple players</a></li>
<li><a href="http://davesquared.net/2009/03/garden-race-pt-3-its-gui-time.html">Part 3: It's GUI time!</a> (an exercise in WPF abuse)</li>
<li>...</li>
</ul>




<p style="font-size: xx-small">Note: This is post has been back-dated to appear before the other posts in the series. It was written after Part 2.</p>

]]></content>
  </entry>
  
</feed>
